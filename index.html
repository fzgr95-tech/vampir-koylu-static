<!DOCTYPE html>
<html lang="tr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vampir K√∂yl√º</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;500;700&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        :root {
            --bg-color: #0f0c29;
            --primary-color: #00d4ff;
            --secondary-color: #ff0055;
            --accent-color: #7000ff;
            --text-color: #ffffff;
            --glass-bg: rgba(255, 255, 255, 0.05);
            --glass-border: rgba(255, 255, 255, 0.1);
            --card-radius: 16px;
            --font-main: 'Outfit', sans-serif;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            background: linear-gradient(135deg, #0f0c29, #302b63, #24243e);
            color: var(--text-color);
            font-family: var(--font-main);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            width: 100%;
            overflow-x: hidden;
        }

        body.shake {
            animation: shake 0.5s;
        }

        @keyframes shake {
            0% {
                transform: translate(1px, 1px) rotate(0deg);
            }

            10% {
                transform: translate(-1px, -2px) rotate(-1deg);
            }

            20% {
                transform: translate(-3px, 0px) rotate(1deg);
            }

            30% {
                transform: translate(3px, 2px) rotate(0deg);
            }

            40% {
                transform: translate(1px, -1px) rotate(1deg);
            }

            50% {
                transform: translate(-1px, 2px) rotate(-1deg);
            }

            60% {
                transform: translate(-3px, 1px) rotate(0deg);
            }

            70% {
                transform: translate(3px, 1px) rotate(-1deg);
            }

            80% {
                transform: translate(-1px, -1px) rotate(1deg);
            }

            90% {
                transform: translate(1px, 2px) rotate(0deg);
            }

            100% {
                transform: translate(1px, -2px) rotate(-1deg);
            }
        }

        .container {
            width: 100%;
            max-width: 480px;
            padding: 20px;
            margin: 0 auto;
        }

        .screen {
            display: none;
            flex-direction: column;
            align-items: center;
        }

        .screen.active {
            display: flex;
        }

        h1.game-title {
            font-size: 2.5rem;
            font-weight: 700;
            text-align: center;
            margin-bottom: 2rem;
            background: linear-gradient(var(--primary-color), var(--secondary-color));
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .btn {
            border: none;
            padding: 14px 24px;
            border-radius: 12px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            width: 100%;
            margin-bottom: 10px;
            text-transform: uppercase;
            transition: all 0.3s;
        }

        .btn-primary {
            background: var(--primary-color);
            color: #000;
            box-shadow: 0 0 15px var(--primary-color);
        }

        .btn-secondary {
            background: transparent;
            border: 2px solid var(--primary-color);
            color: var(--primary-color);
        }

        .btn-action {
            background: linear-gradient(90deg, var(--secondary-color), var(--accent-color));
            color: white;
        }

        .btn-text {
            background: transparent;
            color: rgba(255, 255, 255, 0.6);
            text-decoration: underline;
        }

        input {
            width: 100%;
            padding: 12px;
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: white;
            font-family: inherit;
            font-size: 1rem;
            margin-bottom: 10px;
        }

        input:focus {
            outline: none;
            border-color: var(--primary-color);
        }

        .form-section {
            background: var(--glass-bg);
            border: 1px solid var(--glass-border);
            padding: 20px;
            border-radius: var(--card-radius);
            width: 100%;
            margin-top: 15px;
        }

        .hidden {
            display: none !important;
        }

        .players-list {
            width: 100%;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            margin: 20px 0;
        }

        .player-card {
            background: var(--glass-bg);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            padding: 15px;
            text-align: center;
            min-width: 100px;
        }

        .player-avatar {
            width: 50px;
            height: 50px;
            background: var(--accent-color);
            border-radius: 50%;
            margin: 0 auto 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5rem;
            font-weight: bold;
        }

        .role-badge {
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: bold;
            text-transform: uppercase;
            margin-bottom: 15px;
            border: 1px solid;
            background: rgba(0, 0, 0, 0.3);
        }

        .role-vampire {
            color: var(--secondary-color);
            border-color: var(--secondary-color);
        }

        .role-villager {
            color: var(--primary-color);
            border-color: var(--primary-color);
        }

        .role-doctor {
            color: #00ff64;
            border-color: #00ff64;
        }

        .role-seer {
            color: #b400ff;
            border-color: #b400ff;
        }

        .role-traitor {
            color: #ff9600;
            border-color: #ff9600;
        }

        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            padding: 10px 0;
            margin-bottom: 15px;
        }

        .phase-indicator {
            font-size: 1.2rem;
            font-weight: bold;
        }

        .countdown {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--primary-color);
            padding: 5px 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
        }

        .countdown-urgent {
            color: var(--secondary-color);
        }

        .chat-container {
            background: var(--glass-bg);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            padding: 10px;
            margin-top: 15px;
            width: 100%;
        }

        .chat-messages {
            max-height: 150px;
            overflow-y: auto;
            padding: 5px;
        }

        .chat-message {
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 0.9rem;
        }

        .chat-input-area {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .chat-input-area input {
            flex: 1;
            margin-bottom: 0;
        }

        .chat-input-area button {
            width: auto;
            padding: 12px 20px;
        }

        .toast-container {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
        }

        .toast {
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 12px 24px;
            border-radius: 8px;
            margin-bottom: 10px;
            border-left: 4px solid var(--primary-color);
        }

        .toast.error {
            border-color: var(--secondary-color);
        }

        .toast.chaos {
            border-color: #ff9600;
        }

        .night-mode {
            background: #000 !important;
        }

        .night-mode .container {
            background: rgba(50, 0, 0, 0.3);
        }

        .vote-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            width: 100%;
            margin-top: 15px;
        }

        .vote-card {
            background: var(--glass-bg);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            padding: 15px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
        }

        .vote-card:hover {
            border-color: var(--primary-color);
            box-shadow: 0 0 15px rgba(0, 212, 255, 0.2);
        }

        .vote-card.is-dead {
            opacity: 0.4;
            pointer-events: none;
        }

        .chaos-banner {
            background: rgba(255, 150, 0, 0.2);
            border: 1px solid #ff9600;
            color: #ff9600;
            padding: 10px;
            border-radius: 8px;
            text-align: center;
            margin-bottom: 15px;
            display: none;
            animation: pulse-border 2s infinite;
        }

        @keyframes pulse-border {
            0% {
                border-color: #ff9600;
                box-shadow: 0 0 5px #ff9600;
            }

            50% {
                border-color: #ff0000;
                box-shadow: 0 0 15px #ff0000;
            }

            100% {
                border-color: #ff9600;
                box-shadow: 0 0 5px #ff9600;
            }
        }

        #duel-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 2000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        #duel-btn {
            width: 200px;
            height: 200px;
            border-radius: 50%;
            background: var(--secondary-color);
            border: 5px solid white;
            font-size: 2rem;
            color: white;
            cursor: pointer;
            animation: pulse-fast 0.5s infinite;
        }

        @keyframes pulse-fast {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.1);
            }

            100% {
                transform: scale(1);
            }
        }

        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(0, 212, 255, 0.4);
            }

            70% {
                box-shadow: 0 0 0 20px rgba(0, 212, 255, 0);
            }

            100% {
                box-shadow: 0 0 0 0 rgba(0, 212, 255, 0);
            }
        }

        .pulse {
            animation: pulse 2s infinite;
        }
    </style>
</head>

<body>
    <div class="container">
        <!-- ANA EKRAN -->
        <div id="screen-home" class="screen active">
            <h1 class="game-title">üßõ VAMPƒ∞R K√ñYL√ú<br><small style="font-size:1rem;color:#aaa">ULTIMATE EDITION</small>
            </h1>

            <div class="form-section">
                <input type="text" id="username-input" placeholder="Kullanƒ±cƒ± Adƒ±n">

                <button class="btn btn-primary" onclick="showCreateRoom()">üè† Oda Kur</button>
                <button class="btn btn-secondary" onclick="showJoinRoom()">üö™ Odaya Katƒ±l</button>
            </div>

            <!-- Aktif Odalar Listesi -->
            <div id="room-list-container" class="form-section" style="margin-top: 20px;">
                <h3 style="margin-bottom: 10px; font-size: 1.1rem;">üî• Aktif Odalar</h3>
                <div id="active-rooms-list" style="max-height: 200px; overflow-y: auto;">
                    <p style="color: rgba(255,255,255,0.5); font-size: 0.9rem;">Oda aranƒ±yor...</p>
                </div>
            </div>

            <!-- Oda Kurma -->
            <div id="create-form" class="form-section hidden">
                <h3 style="margin-bottom: 15px;">Oda Olu≈ütur</h3>
                <input type="text" id="room-name-input" placeholder="Oda ƒ∞smi">
                <input type="password" id="room-password-input" placeholder="≈ûifre (ƒ∞steƒüe Baƒülƒ±)">
                <input type="number" id="vampire-count-input" value="1" min="1" max="3" placeholder="Vampir Sayƒ±sƒ±">
                <input type="number" id="duration-input" value="60" min="30" max="180"
                    placeholder="Tartƒ±≈üma S√ºresi (sn)">
                <button class="btn btn-action" onclick="createRoom()">Olu≈ütur</button>
                <button class="btn btn-text" onclick="hideCreateRoom()">ƒ∞ptal</button>
            </div>

            <!-- Odaya Katƒ±lma -->
            <div id="join-form" class="form-section hidden">
                <h3 style="margin-bottom: 15px;">Odaya Katƒ±l</h3>
                <input type="text" id="room-code-input" placeholder="Oda Kodu">
                <input type="password" id="join-password-input" placeholder="≈ûifre (Varsa)">
                <button class="btn btn-action" onclick="joinRoom()">Katƒ±l</button>
                <button class="btn btn-text" onclick="hideJoinRoom()">ƒ∞ptal</button>
            </div>
        </div>

        <!-- LOBƒ∞ EKRANI -->
        <div id="screen-lobby" class="screen">
            <h2 style="text-align: center; margin-bottom: 10px;" id="lobby-title">Lobi</h2>
            <p style="text-align: center; margin-bottom: 20px;">
                Oda Kodu: <strong id="room-code-display" style="color: var(--primary-color);"></strong>
                <button onclick="copyRoomCode()"
                    style="background: none; border: none; color: var(--primary-color); cursor: pointer; font-size: 1rem;">üìã</button>
            </p>

            <div class="players-list" id="lobby-players"></div>

            <div id="host-controls" class="hidden" style="width: 100%;">
                <button class="btn btn-primary pulse" onclick="startGame()">üéÆ Oyunu Ba≈ülat</button>
            </div>

            <button class="btn btn-text" onclick="leaveLobby()">‚Üê √áƒ±k</button>

            <!-- Lobi Sohbet -->
            <div class="chat-container">
                <h4 style="margin-bottom: 10px;">üí¨ Sohbet</h4>
                <div id="lobby-chat" class="chat-messages"></div>
                <div class="chat-input-area">
                    <input type="text" id="lobby-chat-input" placeholder="Mesaj yaz..."
                        onkeypress="if(event.key==='Enter') sendLobbyChat()">
                    <button class="btn btn-primary" onclick="sendLobbyChat()">‚û§</button>
                </div>
            </div>
        </div>

        <!-- OYUN EKRANI -->
        <div id="screen-game" class="screen">
            <div class="game-header">
                <div class="role-badge" id="role-badge">?</div>
                <div class="phase-indicator" id="phase-display">G√ºnd√ºz</div>
                <div class="countdown" id="countdown">60</div>
            </div>

            <div id="chaos-banner" class="chaos-banner"></div>

            <div id="game-message" style="text-align: center; margin-bottom: 15px; font-size: 1.1rem;"></div>

            <div class="vote-grid" id="players-grid"></div>

            <div id="night-action-panel" class="form-section hidden">
                <h3 id="night-action-title">Gece Aksiyonu</h3>
                <p id="night-action-desc" style="margin-bottom: 15px;"></p>
                <div id="night-targets" class="vote-grid"></div>
            </div>

            <div id="dead-controls" class="form-section hidden">
                <h3>üëª Hayalet Modu</h3>
                <div style="display: flex; gap: 10px; justify-content: center;">
                    <button class="btn btn-secondary" onclick="haunt('vibrate')">üì≥ Titret</button>
                    <button class="btn btn-secondary" onclick="haunt('jumpscare')">üëÅÔ∏è Korkut</button>
                </div>
            </div>

            <!-- Oyun Sohbet -->
            <div class="chat-container">
                <div id="game-chat" class="chat-messages"></div>
                <div class="chat-input-area">
                    <input type="text" id="game-chat-input" placeholder="Mesaj yaz..."
                        onkeypress="if(event.key==='Enter') sendGameChat()">
                    <button class="btn btn-primary" onclick="sendGameChat()">‚û§</button>
                </div>
            </div>
        </div>

        <!-- OYUN SONU EKRANI -->
        <div id="screen-end" class="screen">
            <h1 id="end-title" style="font-size: 2rem; text-align: center; margin-bottom: 20px;"></h1>
            <p id="end-message" style="text-align: center; margin-bottom: 30px;"></p>
            <button class="btn btn-primary" onclick="backToHome()">Ana Men√ºye D√∂n</button>
        </div>

        <!-- DUEL OVERLAY -->
        <div id="duel-overlay" class="hidden">
            <h2 style="color: white; margin-bottom: 20px;">D√úELLO!</h2>
            <button id="duel-btn" onclick="duelClick()">TIKLA!</button>
        </div>
    </div>

    <div class="toast-container" id="toast-container"></div>

    <script>
        // ========== GLOBAL STATE ==========
        let peer = null;
        let connections = {};
        let isHost = false;
        let myPeerId = null;
        let myUsername = '';
        let roomCode = '';
        let hostConnection = null;

        // Lobby System
        let lobbyConnection = null;
        let isLobbyManager = false;
        // G√ºnl√ºk ID deƒüi≈üimi basit √ß√∂z√ºm (Herkes aynƒ± g√ºn aynƒ± lobiye d√º≈üecek)
        const LOBBY_ID = 'vampir-koylu-master-lobby-' + new Date().getDate();

        let gameState = {
            phase: 'lobby',
            players: {},
            vampireCount: 1,
            duration: 60,
            roomName: '',
            password: '',
            nightActions: {},
            countdown: 60,
            chaosEvent: null,
            duelScores: {}
        };

        let countdownInterval = null;

        // ========== UTILITIES ==========
        function showScreen(name) {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            document.getElementById('screen-' + name).classList.add('active');
        }

        function showToast(message, type = 'info') {
            const container = document.getElementById('toast-container');
            const toast = document.createElement('div');
            toast.className = 'toast ' + type;
            toast.innerText = message;
            container.appendChild(toast);
            setTimeout(() => toast.remove(), 3000);
        }

        function generateRoomCode() {
            const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
            let code = '';
            for (let i = 0; i < 4; i++) {
                code += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return code;
        }

        function copyRoomCode() {
            navigator.clipboard.writeText(roomCode);
            showToast('Oda kodu kopyalandƒ±!');
        }

        // ========== PEER CONNECTION ==========
        async function initApp() {
            await initPeer();
            connectToLobby();
        }

        function initPeer(id = null) {
            return new Promise((resolve, reject) => {
                peer = id ? new Peer(id) : new Peer();

                peer.on('open', (peerId) => {
                    myPeerId = peerId;
                    console.log('My ID:', peerId);
                    resolve(peerId);
                });

                peer.on('connection', (conn) => {
                    handleNewConnection(conn);
                });

                peer.on('error', (err) => {
                    console.log('Peer error:', err.type);
                    if (err.type === 'unavailable-id') {
                        if (id === LOBBY_ID) connectToLobby();
                        else showToast('Bu oda kodu kullanƒ±mda!', 'error');
                    }
                    // reject(err); 
                });
            });
        }

        // LOBBY LOGIC
        function connectToLobby() {
            if (myPeerId === LOBBY_ID) return;

            const conn = peer.connect(LOBBY_ID);

            conn.on('open', () => {
                console.log('Connected to Lobby');
                lobbyConnection = conn;
                conn.send({ type: 'get_rooms' });
                conn.on('data', (data) => {
                    if (data.type === 'room_list') updateRoomListUI(data.rooms);
                });
            });

            conn.on('error', () => {
                becomeLobbyManager();
            });

            setTimeout(() => {
                if (!lobbyConnection && !isLobbyManager) becomeLobbyManager();
            }, 3000);
        }

        async function becomeLobbyManager() {
            if (isLobbyManager) return;
            if (peer) peer.destroy();

            try {
                await initPeer(LOBBY_ID);
                isLobbyManager = true;
                console.log('I am Lobby Manager');
                showToast('Lobi Y√∂neticisi Oldun!', 'info');
                updateRoomListUI(knownRooms);
            } catch (e) {
                initPeer();
                setTimeout(connectToLobby, 2000);
            }
        }

        let knownRooms = {};

        function handleLobbyMessage(conn, data) {
            if (data.type === 'register_room') {
                knownRooms[data.code] = data.info;
                broadcastRooms();
            } else if (data.type === 'get_rooms') {
                conn.send({ type: 'room_list', rooms: knownRooms });
            }
        }

        function broadcastRooms() {
            Object.values(connections).forEach(c => {
                if (c.open) c.send({ type: 'room_list', rooms: knownRooms });
            });
        }

        function updateRoomListUI(rooms) {
            const list = document.getElementById('active-rooms-list');
            list.innerHTML = '';

            const roomKeys = Object.keys(rooms);
            if (roomKeys.length === 0) {
                list.innerHTML = '<p style="opacity:0.6;font-size:0.9rem;">Aktif oda yok.</p>';
                return;
            }

            roomKeys.forEach(code => {
                const r = rooms[code];
                const div = document.createElement('div');
                div.style.background = 'rgba(255,255,255,0.1)';
                div.style.padding = '10px';
                div.style.borderRadius = '8px';
                div.style.marginBottom = '5px';
                div.style.display = 'flex';
                div.style.justifyContent = 'space-between';
                div.style.alignItems = 'center';
                div.style.cursor = 'pointer';
                div.onclick = () => {
                    document.getElementById('room-code-input').value = code;
                    showJoinRoom();
                };

                div.innerHTML = `<div><strong>${r.name}</strong> ${r.locked ? 'üîí' : ''}<br><small style="color:#aaa">${code}</small></div>`;
                list.appendChild(div);
            });
        }

        function handleNewConnection(conn) {
            conn.on('open', () => {
                connections[conn.peer] = conn;
                conn.on('data', (data) => {
                    if (isLobbyManager) handleLobbyMessage(conn, data);
                    else handleMessage(conn.peer, data);
                });
                conn.on('close', () => handleDisconnect(conn.peer));
            });
        }

        function handleDisconnect(peerId) {
            delete connections[peerId];
            if (isHost && gameState.players[peerId]) {
                delete gameState.players[peerId];
                broadcastState();
            }
        }

        function broadcast(data) {
            Object.values(connections).forEach(conn => {
                if (conn.open) conn.send(data);
            });
        }

        function sendToHost(data) {
            if (hostConnection && hostConnection.open) {
                hostConnection.send(data);
            }
        }

        function handleMessage(fromPeerId, data) {
            switch (data.type) {
                case 'join':
                    if (isHost) {
                        // ≈ûifre Kontrol√º
                        if (gameState.password && gameState.password !== data.password) {
                            const conn = connections[fromPeerId];
                            if (conn) {
                                conn.send({ type: 'chat', sender: 'Sƒ∞STEM', message: 'Hatalƒ± ≈ûifre! Baƒülantƒ± kesiliyor...', chatType: 'lobby' });
                                setTimeout(() => conn.close(), 1000);
                            }
                            return;
                        }

                        gameState.players[fromPeerId] = {
                            name: data.username,
                            role: null,
                            isAlive: true,
                            vote: null
                        };
                        broadcastState();
                    }
                    break;

                case 'state':
                    gameState = data.state;
                    updateUI();
                    break;

                case 'chat':
                    addChatMessage(data.sender, data.message, data.chatType, data.isGhost);
                    if (isHost) broadcast(data);
                    break;

                case 'notification':
                    showToast(data.message, data.urgency === 'high' ? 'error' : 'info');
                    if (data.urgency === 'high' && navigator.vibrate) navigator.vibrate([200, 100, 200]);
                    break;

                case 'vote':
                    if (isHost) {
                        gameState.players[fromPeerId].vote = data.target;
                        checkAllVoted();
                    }
                    break;

                case 'night_action':
                    if (isHost) {
                        gameState.nightActions[fromPeerId] = { action: data.action, target: data.target };
                        checkAllNightActions();
                    }
                    break;

                case 'haunt':
                    if (isHost) broadcast({ type: 'haunt_effect', effect: data.effect });
                    break;

                case 'haunt_effect':
                    triggerHauntEffect(data.effect);
                    break;

                case 'duel_start':
                    showDuelOverlay();
                    break;

                case 'duel_click':
                    if (isHost) {
                        gameState.duelScores[fromPeerId] = (gameState.duelScores[fromPeerId] || 0) + 1;
                        // Host logic decides winner (simplified: first to 10 or most in 5 sec)
                    }
                    break;

                case 'game_start':
                    showScreen('game');
                    break;

                case 'game_end':
                    showEndScreen(data.winner, data.message);
                    break;
            }
        }

        function broadcastState() {
            broadcast({ type: 'state', state: gameState });
            updateUI();
        }

        // ========== ROOM & GAME LOGIC ==========
        async function createRoom() {
            myUsername = document.getElementById('username-input').value.trim();
            if (!myUsername) return showToast('ƒ∞sim gir!', 'error');

            roomCode = generateRoomCode();
            gameState.roomName = document.getElementById('room-name-input').value || 'Oda ' + roomCode;
            gameState.password = document.getElementById('room-password-input').value.trim();
            gameState.vampireCount = parseInt(document.getElementById('vampire-count-input').value);
            gameState.duration = parseInt(document.getElementById('duration-input').value);

            try {
                // If I was manager, stop being manager
                if (isLobbyManager) {
                    isLobbyManager = false;
                    if (peer) peer.destroy();
                }

                await initPeer(roomCode);
                isHost = true;
                gameState.players[myPeerId] = { name: myUsername, role: null, isAlive: true, vote: null };

                // Register to Lobby
                const conn = peer.connect(LOBBY_ID);
                conn.on('open', () => {
                    conn.send({
                        type: 'register_room',
                        code: roomCode,
                        info: { name: gameState.roomName, locked: !!gameState.password }
                    });
                });

                document.getElementById('room-code-display').innerText = roomCode;
                document.getElementById('lobby-title').innerText = gameState.roomName;
                document.getElementById('host-controls').classList.remove('hidden');

                showScreen('lobby');
                updateLobbyPlayers();
                showToast('Oda kuruldu: ' + roomCode);
            } catch (err) { console.error(err); }
        }

        async function joinRoom() {
            myUsername = document.getElementById('username-input').value.trim();
            roomCode = document.getElementById('room-code-input').value.trim().toUpperCase();
            const password = document.getElementById('join-password-input').value.trim();

            if (!myUsername || !roomCode) return showToast('Bilgileri gir!', 'error');

            try {
                await initPeer();
                hostConnection = peer.connect(roomCode);

                hostConnection.on('open', () => {
                    connections[roomCode] = hostConnection;
                    hostConnection.send({ type: 'join', username: myUsername, password: password });

                    hostConnection.on('data', d => handleMessage(roomCode, d));
                    document.getElementById('room-code-display').innerText = roomCode;
                    showScreen('lobby');
                });
                hostConnection.on('error', () => showToast('Baƒülantƒ± hatasƒ±!', 'error'));
            } catch (err) { console.error(err); }
        }

        function startGame() {
            if (!isHost) return;
            const pIds = Object.keys(gameState.players);
            if (pIds.length < gameState.vampireCount + 2) return showToast('Yetersiz oyuncu!', 'error');

            // Roles
            let roles = [];
            for (let i = 0; i < gameState.vampireCount; i++) roles.push('vampire');
            if (pIds.length > 3) roles.push('doctor');
            if (pIds.length > 4) roles.push('seer');
            if (pIds.length > 5) roles.push('traitor'); // K√∂stebek
            while (roles.length < pIds.length) roles.push('villager');

            // Shuffle
            roles = roles.sort(() => Math.random() - 0.5);

            pIds.forEach((id, i) => {
                gameState.players[id].role = roles[i];
                gameState.players[id].isAlive = true;
                gameState.players[id].vote = null;
            });

            broadcast({ type: 'game_start' });
            showScreen('game');
            startDayPhase();
        }

        function startDayPhase() {
            gameState.phase = 'day';
            gameState.countdown = gameState.duration;
            gameState.chaosEvent = null;

            // Chaos Event (%50 ≈üans)
            const events = [
                { id: 'blind', name: 'üôà K√ñR ADALET', desc: 'Oylar gizli olacak!' },
                { id: 'silence', name: 'ü§ê SESSƒ∞ZLƒ∞K', desc: 'Konu≈ümak yasak!' },
                { id: 'double', name: '‚ö° √áƒ∞FTE BELA', desc: 'ƒ∞ki ki≈üi asƒ±lacak!' }
            ];

            if (Math.random() > 0.5) {
                gameState.chaosEvent = events[Math.floor(Math.random() * events.length)];
            }

            broadcastState();
            startCountdown(() => startVotingPhase());
        }

        function startVotingPhase() {
            gameState.phase = 'voting';
            gameState.countdown = 30;
            Object.values(gameState.players).forEach(p => p.vote = null);
            broadcastState();
            broadcast({ type: 'notification', message: '‚ö†Ô∏è OYLAMA BA≈ûLADI! 30 saniyeniz var!', urgency: 'high' });
            startCountdown(() => resolveVotes());
        }

        function startNightPhase() {
            gameState.phase = 'night';
            gameState.nightActions = {};
            gameState.countdown = 30;
            broadcastState();
            startCountdown(() => resolveNight());
        }

        function startCountdown(cb) {
            if (countdownInterval) clearInterval(countdownInterval);

            // Initial sync
            broadcastState();

            countdownInterval = setInterval(() => {
                gameState.countdown--;

                if (isHost) {
                    document.getElementById('countdown').innerText = gameState.countdown;
                    // Broadcast every second for better sync in P2P
                    broadcastState();

                    // Warning near end
                    if (gameState.countdown === 10) {
                        broadcast({ type: 'notification', message: '‚è≥ Son 10 Saniye!', urgency: 'medium' });
                    }
                }

                if (gameState.countdown <= 0) {
                    clearInterval(countdownInterval);
                    if (cb) cb();
                }
            }, 1000);
        }

        function castVote(targetId) {
            const me = gameState.players[myPeerId];
            if (!me.isAlive) return;

            if (isHost) {
                me.vote = targetId;
                checkAllVoted();
            } else {
                sendToHost({ type: 'vote', target: targetId });
            }
            showToast('Oy verildi!');
            // Disable buttons
            document.querySelectorAll('.vote-card').forEach(b => b.style.pointerEvents = 'none');
        }

        function checkAllVoted() {
            const alive = Object.values(gameState.players).filter(p => p.isAlive);
            const voted = alive.filter(p => p.vote);
            if (voted.length >= alive.length) resolveVotes();
        }

        function resolveVotes() {
            clearInterval(countdownInterval);
            const votes = {};
            Object.values(gameState.players).forEach(p => {
                if (p.isAlive && p.vote) votes[p.vote] = (votes[p.vote] || 0) + 1;
            });

            // Logic for max votes
            // If chaosEvent is 'blind', show results only now
            let max = 0;
            let victims = [];
            Object.entries(votes).forEach(([id, c]) => {
                if (c > max) { max = c; victims = [id]; }
                else if (c === max) victims.push(id);
            });

            let msg = '';
            if (victims.length === 1) {
                const v = gameState.players[victims[0]];
                v.isAlive = false;
                msg = `‚ö∞Ô∏è ${v.name} asƒ±ldƒ±! Rol√º: ${getRoleEmoji(v.role)}`;
            } else {
                msg = '‚öñÔ∏è Oylar e≈üit, kimse asƒ±lmadƒ±.';
                if (gameState.chaosEvent?.id === 'double' && victims.length === 2) {
                    // Double trouble logic
                    victims.forEach(id => gameState.players[id].isAlive = false);
                    msg = `‚ö° √áƒ∞FTE BELA! ${gameState.players[victims[0]].name} ve ${gameState.players[victims[1]].name} asƒ±ldƒ±!`;
                }
                else if (gameState.chaosEvent?.id === 'duel' && victims.length === 2) {
                    // Trigger duel?
                    // For simplicity, stick to standard double mechanic or tie = no death
                }
            }

            document.getElementById('game-message').innerText = msg;
            broadcastState();

            if (!checkWin()) setTimeout(() => startNightPhase(), 4000);
        }

        function resolveNight() {
            clearInterval(countdownInterval);
            // Logic: Vampire kills, Doctor protects, Seer inspected locally
            const kills = [];
            const protects = [];

            Object.values(gameState.nightActions).forEach(a => {
                if (a.action === 'kill') kills.push(a.target);
                if (a.action === 'protect') protects.push(a.target);
            });

            let victim = kills[0]; // Simplification: 1 kill
            let msg = 'üåô Gece sessiz ge√ßti.';

            if (victim) {
                if (protects.includes(victim)) {
                    msg = 'üíâ Doktor m√ºdahalesi hayat kurtardƒ±!';
                } else {
                    const p = gameState.players[victim];
                    p.isAlive = false;
                    msg = `üíÄ ${p.name} √∂l√º bulundu!`;
                }
            }

            document.getElementById('game-message').innerText = msg;
            broadcastState();

            if (!checkWin()) setTimeout(() => startDayPhase(), 4000);
        }

        function checkWin() {
            const alive = Object.values(gameState.players).filter(p => p.isAlive);
            const vamps = alive.filter(p => p.role === 'vampire');
            const norms = alive.filter(p => p.role !== 'vampire'); // Traitor counts as norm for survival but helps vamps?

            // Usually win if Vamps >= Norms
            if (vamps.length === 0) {
                endGame('villagers', 'K√∂yl√ºler kazandƒ±! Vampirler temizlendi.');
                return true;
            }
            if (vamps.length >= norms.length) {
                endGame('vampires', 'Vampirler k√∂y√º ele ge√ßirdi!');
                return true;
            }
            return false;
        }

        function endGame(winner, msg) {
            broadcast({ type: 'game_end', winner, message: msg });
            showEndScreen(winner, msg);
        }

        // ========== CLIENT UI ==========
        function updateUI() {
            if (gameState.phase === 'lobby') {
                updateLobbyPlayers();
                return;
            }
            // Game UI
            const me = gameState.players[myPeerId];
            if (!me) return;

            // Header
            document.getElementById('role-badge').innerText = getRoleEmoji(me.role) + ' ' + me.role.toUpperCase();
            document.getElementById('role-badge').className = `role-badge role-${me.role}`;
            document.getElementById('phase-display').innerText = gameState.phase === 'day' ? '‚òÄÔ∏è G√úND√úZ' : (gameState.phase === 'night' ? 'üåô GECE' : 'üó≥Ô∏è OYLAMA');
            document.getElementById('countdown').innerText = gameState.countdown;

            // Chaos Banner
            const banner = document.getElementById('chaos-banner');
            if (gameState.chaosEvent) {
                banner.innerText = `${gameState.chaosEvent.name}: ${gameState.chaosEvent.desc}`;
                banner.style.display = 'block';
            } else {
                banner.style.display = 'none';
            }

            // Grid
            const grid = document.getElementById('players-grid');
            grid.innerHTML = '';

            const showingVotes = (gameState.phase === 'voting'); // Or end of vote
            // In voting phase, we usually hide votes until result

            Object.entries(gameState.players).forEach(([id, p]) => {
                const div = document.createElement('div');
                div.className = `vote-card ${p.isAlive ? '' : 'is-dead'}`;
                div.innerHTML = `
                    <div class="player-avatar">${p.name[0]}</div>
                    <div class="player-name">${p.name}</div>
                    ${!p.isAlive ? '<small>üíÄ √ñl√º</small>' : ''}
                 `;

                if (gameState.phase === 'voting' && id !== myPeerId && me.isAlive) {
                    div.onclick = () => castVote(id);
                }
                grid.appendChild(div);
            });

            // Night Panel
            const nightPanel = document.getElementById('night-action-panel');
            if (gameState.phase === 'night' && me.isAlive && ['vampire', 'doctor', 'seer'].includes(me.role)) {
                nightPanel.classList.remove('hidden');
                document.getElementById('night-targets').innerHTML = '';

                let title = '', desc = '', action = '';
                if (me.role === 'vampire') { title = 'AV'; desc = '√ñld√ºr'; action = 'kill'; }
                if (me.role === 'doctor') { title = 'ƒ∞LKYARDIM'; desc = 'Koru'; action = 'protect'; }
                if (me.role === 'seer') { title = 'KEHANET'; desc = 'Sorgula'; action = 'inspect'; }

                document.getElementById('night-action-title').innerText = title;
                document.getElementById('night-action-desc').innerText = desc;

                Object.entries(gameState.players).forEach(([id, p]) => {
                    if (!p.isAlive || id === myPeerId) return; // Can't target self usually? Doctor can. 
                    // Simplified: Doctor CAN self-protect. Vampire CAN kill partner (troll). 
                    const btn = document.createElement('div');
                    btn.className = 'vote-card';
                    btn.innerHTML = p.name;
                    btn.style.padding = '10px';
                    btn.onclick = () => {
                        if (isHost) {
                            gameState.nightActions[myPeerId] = { action, target: id };
                            if (action === 'inspect') showToast(`${p.name} bir ${p.role === 'vampire' || p.role === 'traitor' ? 'D√ú≈ûMAN' : 'DOST'}`); // Traitor appears as enemy? Or Villager? Usually Seer sees Traitor.
                            checkAllNightActions();
                        } else {
                            sendToHost({ type: 'night_action', action, target: id });
                        }
                        nightPanel.classList.add('hidden');
                    };
                    document.getElementById('night-targets').appendChild(btn);
                });
            } else {
                nightPanel.classList.add('hidden');
            }

            // Dead Controls
            if (!me.isAlive) {
                document.getElementById('dead-controls').classList.remove('hidden');
            } else {
                document.getElementById('dead-controls').classList.add('hidden');
            }
        }

        function updateLobbyPlayers() {
            const list = document.getElementById('lobby-players');
            list.innerHTML = '';
            Object.values(gameState.players).forEach(p => {
                const div = document.createElement('div');
                div.className = 'player-card';
                div.innerText = p.name;
                list.appendChild(div);
            });
        }

        function getRoleEmoji(role) {
            const map = { vampire: 'üßõ', villager: 'üë®‚Äçüåæ', doctor: 'üíâ', seer: 'üîÆ', traitor: 'üêÄ' };
            return map[role] || '‚ùì';
        }

        function backToHome() {
            if (peer) peer.destroy();
            location.reload();
        }

        function sendLobbyChat() {
            const inp = document.getElementById('lobby-chat-input');
            const msg = inp.value.trim();
            if (!msg) return;
            const data = { type: 'chat', sender: myUsername, message: msg, chatType: 'lobby' };
            if (isHost) {
                addChatMessage(myUsername, msg, 'lobby');
                broadcast(data);
            } else sendToHost(data);
            inp.value = '';
        }

        function sendGameChat() {
            const inp = document.getElementById('game-chat-input');
            const msg = inp.value.trim();
            if (!msg) return;
            const me = gameState.players[myPeerId];
            const isGhost = !me.isAlive;
            const data = { type: 'chat', sender: myUsername, message: msg, chatType: 'game', isGhost };
            if (isHost) {
                addChatMessage(myUsername, msg, 'game', isGhost);
                broadcast(data);
            } else sendToHost(data);
            inp.value = '';
        }

        function addChatMessage(sender, msg, type, isGhost) {
            const box = document.getElementById(type === 'lobby' ? 'lobby-chat' : 'game-chat');
            const div = document.createElement('div');
            div.className = 'chat-message';
            if (isGhost) div.style.opacity = 0.6;
            div.innerHTML = `${isGhost ? 'üëª ' : ''}<strong style="color:var(--primary-color)">${sender}:</strong> ${msg}`;
            box.appendChild(div);
            box.scrollTop = box.scrollHeight;
        }

        // Dead Actions
        function haunt(effect) {
            sendToHost({ type: 'haunt', effect });
        }

        function triggerHauntEffect(effect) {
            if (effect === 'vibrate') {
                if (navigator.vibrate) navigator.vibrate([200, 100, 200]);
                document.body.classList.add('shake');
                setTimeout(() => document.body.classList.remove('shake'), 500);
                showToast('üëª Biri seni titretiyor!', 'chaos');
            } else if (effect === 'jumpscare') {
                const ol = document.createElement('div');
                ol.style.position = 'fixed'; ol.style.top = 0; ol.style.left = 0; ol.style.width = '100%'; ol.style.height = '100%';
                ol.style.background = 'white'; ol.style.zIndex = 9999;
                document.body.appendChild(ol);
                setTimeout(() => ol.remove(), 100);
            }
        }

        // Host Helper to determine next phase logic needed
        function checkAllNightActions() {
            // simplified count check
            // In P2P host needs to know who is special.
            // We can check gameState.players roles.
        }

        // Listeners for UI interaction
        function showCreateRoom() { document.getElementById('create-form').classList.remove('hidden'); document.getElementById('join-form').classList.add('hidden'); }
        function showJoinRoom() { document.getElementById('join-form').classList.remove('hidden'); document.getElementById('create-form').classList.add('hidden'); }
        function hideCreateRoom() { document.getElementById('create-form').classList.add('hidden'); }
        function hideJoinRoom() { document.getElementById('join-form').classList.add('hidden'); }
        function leaveLobby() { backToHome(); }

        // Start App
        initApp();
    </script>
</body>

</html>