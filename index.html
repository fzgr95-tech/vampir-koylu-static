<!DOCTYPE html>
<html lang="tr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>VAMPƒ∞R K√ñYL√ú 1.3</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;500;700&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        :root {
            --bg-color: #0f0c29;
            --primary-color: #00d4ff;
            --secondary-color: #ff0055;
            --accent-color: #7000ff;
            --text-color: #ffffff;
            --glass-bg: rgba(255, 255, 255, 0.05);
            --glass-border: rgba(255, 255, 255, 0.1);
            --card-radius: 16px;
            --font-main: 'Outfit', sans-serif;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            background: linear-gradient(135deg, #0f0c29, #302b63, #24243e);
            color: var(--text-color);
            font-family: var(--font-main);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            width: 100%;
            overflow-x: hidden;
        }

        body.shake {
            animation: shake 0.5s;
        }

        @keyframes shake {
            0% {
                transform: translate(1px, 1px) rotate(0deg);
            }

            10% {
                transform: translate(-1px, -2px) rotate(-1deg);
            }

            20% {
                transform: translate(-3px, 0px) rotate(1deg);
            }

            30% {
                transform: translate(3px, 2px) rotate(0deg);
            }

            40% {
                transform: translate(1px, -1px) rotate(1deg);
            }

            50% {
                transform: translate(-1px, 2px) rotate(-1deg);
            }

            60% {
                transform: translate(-3px, 1px) rotate(0deg);
            }

            70% {
                transform: translate(3px, 1px) rotate(-1deg);
            }

            80% {
                transform: translate(-1px, -1px) rotate(1deg);
            }

            90% {
                transform: translate(1px, 2px) rotate(0deg);
            }

            100% {
                transform: translate(1px, -2px) rotate(-1deg);
            }
        }

        .container {
            width: 100%;
            max-width: 480px;
            padding: 20px;
            margin: 0 auto;
        }

        .screen {
            display: none;
            flex-direction: column;
            align-items: center;
        }

        .screen.active {
            display: flex;
        }

        h1.game-title {
            font-size: 2.5rem;
            font-weight: 700;
            text-align: center;
            margin-bottom: 2rem;
            background: linear-gradient(var(--primary-color), var(--secondary-color));
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .btn {
            border: none;
            padding: 14px 24px;
            border-radius: 12px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            width: 100%;
            margin-bottom: 10px;
            text-transform: uppercase;
            transition: all 0.3s;
        }

        .btn-primary {
            background: var(--primary-color);
            color: #000;
            box-shadow: 0 0 15px var(--primary-color);
        }

        .btn-secondary {
            background: transparent;
            border: 2px solid var(--primary-color);
            color: var(--primary-color);
        }

        .btn-action {
            background: linear-gradient(90deg, var(--secondary-color), var(--accent-color));
            color: white;
        }

        .btn-text {
            background: transparent;
            color: rgba(255, 255, 255, 0.6);
            text-decoration: underline;
        }

        input {
            width: 100%;
            padding: 12px;
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: white;
            font-family: inherit;
            font-size: 1rem;
            margin-bottom: 10px;
        }

        input:focus {
            outline: none;
            border-color: var(--primary-color);
        }

        .form-section {
            background: var(--glass-bg);
            border: 1px solid var(--glass-border);
            padding: 20px;
            border-radius: var(--card-radius);
            width: 100%;
            margin-top: 15px;
        }

        .hidden {
            display: none !important;
        }

        .players-list {
            width: 100%;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            margin: 20px 0;
        }

        .player-card {
            background: var(--glass-bg);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            padding: 15px;
            text-align: center;
            min-width: 100px;
        }

        .player-avatar {
            width: 50px;
            height: 50px;
            background: var(--accent-color);
            border-radius: 50%;
            margin: 0 auto 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5rem;
            font-weight: bold;
        }

        .role-badge {
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: bold;
            text-transform: uppercase;
            margin-bottom: 15px;
            border: 1px solid;
            background: rgba(0, 0, 0, 0.3);
        }

        .role-vampire {
            color: var(--secondary-color);
            border-color: var(--secondary-color);
        }

        .role-villager {
            color: var(--primary-color);
            border-color: var(--primary-color);
        }

        .role-doctor {
            color: #00ff64;
            border-color: #00ff64;
        }

        .role-seer {
            color: #b400ff;
            border-color: #b400ff;
        }

        .role-traitor {
            color: #ff9600;
            border-color: #ff9600;
        }

        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            padding: 10px 0;
            margin-bottom: 15px;
        }

        .phase-indicator {
            font-size: 1.2rem;
            font-weight: bold;
        }

        .countdown {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--primary-color);
            padding: 5px 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
        }

        .countdown-urgent {
            color: var(--secondary-color);
        }

        .chat-container {
            background: var(--glass-bg);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            padding: 10px;
            margin-top: 15px;
            width: 100%;
        }

        .chat-messages {
            max-height: 150px;
            overflow-y: auto;
            padding: 5px;
        }

        .chat-message {
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 0.9rem;
        }

        .chat-input-area {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .chat-input-area input {
            flex: 1;
            margin-bottom: 0;
        }

        .chat-input-area button {
            width: auto;
            padding: 12px 20px;
        }

        .toast-container {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
        }

        .toast {
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 12px 24px;
            border-radius: 8px;
            margin-bottom: 10px;
            border-left: 4px solid var(--primary-color);
        }

        .toast.error {
            border-color: var(--secondary-color);
        }

        .toast.chaos {
            border-color: #ff9600;
        }

        .night-mode {
            background: #000 !important;
        }

        .night-mode .container {
            background: rgba(50, 0, 0, 0.3);
        }

        .vote-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            width: 100%;
            margin-top: 15px;
        }

        .vote-card {
            background: var(--glass-bg);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            padding: 15px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
        }

        .vote-card:hover {
            border-color: var(--primary-color);
            box-shadow: 0 0 15px rgba(0, 212, 255, 0.2);
        }

        .vote-card.is-dead {
            opacity: 0.4;
            pointer-events: none;
        }

        .chaos-banner {
            background: rgba(255, 150, 0, 0.2);
            border: 1px solid #ff9600;
            color: #ff9600;
            padding: 10px;
            border-radius: 8px;
            text-align: center;
            margin-bottom: 15px;
            display: none;
            animation: pulse-border 2s infinite;
        }

        @keyframes pulse-border {
            0% {
                border-color: #ff9600;
                box-shadow: 0 0 5px #ff9600;
            }

            50% {
                border-color: #ff0000;
                box-shadow: 0 0 15px #ff0000;
            }

            100% {
                border-color: #ff9600;
                box-shadow: 0 0 5px #ff9600;
            }
        }

        #duel-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 2000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        #duel-btn {
            width: 200px;
            height: 200px;
            border-radius: 50%;
            background: var(--secondary-color);
            border: 5px solid white;
            font-size: 2rem;
            color: white;
            cursor: pointer;
            animation: pulse-fast 0.5s infinite;
        }

        @keyframes pulse-fast {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.1);
            }

            100% {
                transform: scale(1);
            }
        }

        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(0, 212, 255, 0.4);
            }

            70% {
                box-shadow: 0 0 0 20px rgba(0, 212, 255, 0);
            }

            100% {
                box-shadow: 0 0 0 0 rgba(0, 212, 255, 0);
            }
        }

        .pulse {
            animation: pulse 2s infinite;
        }
    </style>
</head>

<body>
    <div class="container">
        <!-- ANA EKRAN -->
        <div id="screen-home" class="screen active">
            <h1 class="game-title">üßõ VAMPƒ∞R K√ñYL√ú<br><small style="font-size:1rem;color:#ff3333">v2.5.0 (TIE
                    BREAKER)</small>
            </h1>

            <div class="form-section">
                <input type="text" id="username-input" placeholder="Kullanƒ±cƒ± Adƒ±n">

                <button class="btn btn-primary" onclick="showCreateRoom()">üè† Oda Kur</button>
                <button class="btn btn-secondary" onclick="showJoinRoom()">üö™ Odaya Katƒ±l</button>
            </div>

            <!-- Aktif Odalar Listesi -->
            <div id="room-list-container" class="form-section" style="margin-top: 20px;">
                <h3 style="margin-bottom: 10px; font-size: 1.1rem;">üî• Aktif Odalar</h3>
                <div id="active-rooms-list" style="max-height: 200px; overflow-y: auto;">
                    <p style="color: rgba(255,255,255,0.5); font-size: 0.9rem;">Oda aranƒ±yor...</p>
                </div>
            </div>

            <div style="text-align: center; margin-top: 20px; opacity: 0.5; font-size: 0.8rem;">
                v1.5 - Voice Chat Ready
            </div>

            <!-- Oda Kurma -->
            <div id="create-form" class="form-section hidden">
                <h3 style="margin-bottom: 15px;">Oda Olu≈ütur</h3>
                <input type="text" id="room-name-input" placeholder="Oda ƒ∞smi">
                <input type="password" id="room-password-input" placeholder="≈ûifre (ƒ∞steƒüe Baƒülƒ±)">
                <input type="number" id="vampire-count-input" value="1" min="1" max="3" placeholder="Vampir Sayƒ±sƒ±">
                <input type="number" id="duration-input" value="60" min="30" max="180"
                    placeholder="Tartƒ±≈üma S√ºresi (sn)">
                <input type="number" id="vote-duration-input" value="30" min="10" max="120"
                    placeholder="Oylama S√ºresi (sn)">

                <!-- Oyun Ayarlarƒ± -->
                <div style="margin: 15px 0; padding: 15px; background: rgba(0,0,0,0.2); border-radius: 8px;">
                    <p style="margin-bottom: 10px; font-weight: bold;">‚öôÔ∏è Oyun Dinamiƒüi:</p>
                    <label style="display: block; margin-bottom: 8px;">
                        <span style="display:block; margin-bottom:5px; font-size:0.9rem;">ü©∏ Vampir Saldƒ±rƒ±sƒ±:</span>
                        <select id="kill-frequency-input"
                            style="width: 100%; padding: 8px; border-radius: 5px; border: none;">
                            <option value="every">Her Gece (Klasik)</option>
                            <option value="alternate">Alternatif (1 Gece Av, 1 Gece Bo≈ü)</option>
                        </select>
                    </label>
                </div>

                <!-- Rol Se√ßimi -->
                <div style="margin: 15px 0; padding: 15px; background: rgba(0,0,0,0.2); border-radius: 8px;">
                    <p style="margin-bottom: 10px; font-weight: bold;">üé≠ √ñzel Roller:</p>
                    <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px; cursor: pointer;">
                        <input type="checkbox" id="role-doctor" checked style="width: auto;">
                        <span>üíâ Doktor (Geceleri korur)</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px; cursor: pointer;">
                        <input type="checkbox" id="role-seer" checked style="width: auto;">
                        <span>üîÆ Medyum (Geceleri sorgular)</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px; cursor: pointer;">
                        <input type="checkbox" id="role-traitor" style="width: auto;">
                        <span>üêÄ K√∂stebek (Vampirlerle √ßalƒ±≈üƒ±r)</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px; cursor: pointer;">
                        <input type="checkbox" id="role-hunter" style="width: auto;">
                        <span>üèπ Avcƒ± (√ñl√ºrken birini g√∂t√ºr√ºr)</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px; cursor: pointer;">
                        <input type="checkbox" id="role-witch" style="width: auto;">
                        <span>‚ú® B√ºy√ºc√º (1x kurtarma + 1x zehir)</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="role-sheriff" style="width: auto;">
                        <span>‚≠ê ≈ûerif (Oyu 2 sayƒ±lƒ±r)</span>
                    </label>
                </div>

                <!-- ƒ∞ttifak Sistemi -->
                <div style="margin: 15px 0; padding: 15px; background: rgba(0,0,0,0.2); border-radius: 8px;">
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="enable-alliance" style="width: auto;">
                        <span>ü§ù <strong>ƒ∞ttifak Sistemi</strong></span>
                    </label>
                    <p style="font-size: 0.85rem; color: rgba(255,255,255,0.6); margin-top: 8px;">
                        Oyuncular grup kurabilir. Gruptaki biri √∂l√ºrse hepsi √∂l√ºr!
                    </p>
                </div>

                <!-- Sesli ƒ∞leti≈üim -->
                <div style="margin: 15px 0; padding: 15px; background: rgba(0,0,0,0.2); border-radius: 8px;">
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="enable-voice" checked style="width: auto;">
                        <span>üéôÔ∏è <strong>Bas-Konu≈ü Sistemi</strong></span>
                    </label>
                    <p style="font-size: 0.85rem; color: rgba(255,255,255,0.6); margin-top: 8px;">
                        Oyuncular butona basarak konu≈üabilir. (√úcretsiz P2P)
                    </p>
                </div>

                <button class="btn btn-action" onclick="createRoom()">Olu≈ütur</button>
                <button class="btn btn-text" onclick="hideCreateRoom()">ƒ∞ptal</button>
            </div>

            <!-- Odaya Katƒ±lma -->
            <div id="join-form" class="form-section hidden">
                <h3 style="margin-bottom: 15px;">Odaya Katƒ±l</h3>
                <input type="text" id="room-code-input" placeholder="Oda Kodu">
                <input type="password" id="join-password-input" placeholder="≈ûifre (Varsa)">
                <button class="btn btn-action" onclick="joinRoom()">Katƒ±l</button>
                <button class="btn btn-text" onclick="hideJoinRoom()">ƒ∞ptal</button>
            </div>
        </div>

        <!-- LOBƒ∞ EKRANI -->
        <div id="screen-lobby" class="screen">
            <h2 style="text-align: center; margin-bottom: 10px;" id="lobby-title">Lobi</h2>
            <p style="text-align: center; margin-bottom: 20px;">
                Oda Kodu: <strong id="room-code-display" style="color: var(--primary-color);"></strong>
                <button onclick="copyRoomCode()"
                    style="background: none; border: none; color: var(--primary-color); cursor: pointer; font-size: 1rem;">üìã</button>
            </p>

            <div class="players-list" id="lobby-players"></div>

            <div id="host-controls" class="hidden" style="width: 100%;">
                <button class="btn btn-primary pulse" onclick="startGame()">üéÆ Oyunu Ba≈ülat</button>
                <button class="btn btn-secondary" onclick="toggleGlobalVoice()" id="btn-toggle-voice"
                    style="margin-top: 10px;">üéôÔ∏è Sesli Sohbet: A√áIK</button>
            </div>



            <button class="btn btn-text" onclick="backToHome()" style="margin-top: 20px;">üè† Ana Men√º</button>
            <!-- Lobi Sohbet -->
            <div class="chat-container">
                <h4 style="margin-bottom: 10px;">üí¨ Sohbet</h4>
                <div id="lobby-chat" class="chat-messages"></div>
                <div class="chat-input-area">
                    <input type="text" id="lobby-chat-input" placeholder="Mesaj yaz..."
                        onkeypress="if(event.key==='Enter') sendLobbyChat()">
                    <button class="btn btn-primary" onclick="sendLobbyChat()">‚û§</button>
                </div>
            </div>
        </div>

        <!-- OYUN EKRANI -->
        <div id="screen-game" class="screen">
            <div class="game-header">
                <div class="role-badge" id="role-badge">?</div>
                <div class="phase-indicator" id="phase-display">G√ºnd√ºz</div>
                <div class="countdown" id="countdown">60</div>
            </div>

            <div id="chaos-banner" class="chaos-banner"></div>

            <div id="game-message" style="text-align: center; margin-bottom: 15px; font-size: 1.1rem;"></div>

            <div class="vote-grid" id="players-grid"></div>

            <div id="night-action-panel" class="form-section hidden">
                <h3 id="night-action-title">Gece Aksiyonu</h3>
                <p id="night-action-desc" style="margin-bottom: 15px;"></p>
                <div id="night-targets" class="vote-grid"></div>
            </div>

            <!-- ƒ∞ttifak Paneli -->
            <div id="alliance-panel" class="form-section hidden">
                <h3>ü§ù ƒ∞ttifak</h3>
                <div id="alliance-status" style="margin-bottom: 10px; font-size: 0.9rem;"></div>
                <div id="alliance-invite-pending" class="hidden"
                    style="background: rgba(255,150,0,0.2); padding: 10px; border-radius: 8px; margin-bottom: 10px;">
                    <p id="alliance-invite-text"></p>
                    <div style="display: flex; gap: 10px; margin-top: 10px;">
                        <button class="btn btn-primary" onclick="acceptAllianceInvite()">‚úì Kabul</button>
                        <button class="btn btn-secondary" onclick="rejectAllianceInvite()">‚úó Reddet</button>
                    </div>
                </div>
                <div id="alliance-actions">
                    <button class="btn btn-secondary" onclick="showAllianceInvitePanel()" id="btn-invite-alliance">üë•
                        Davet G√∂nder</button>
                    <button class="btn btn-text hidden" onclick="leaveAlliance()" id="btn-leave-alliance">üö™ Gruptan
                        Ayrƒ±l</button>
                </div>
                <div id="alliance-invite-panel" class="hidden" style="margin-top: 10px;">
                    <p style="margin-bottom: 10px;">Kimi davet etmek istiyorsun?</p>
                    <div id="alliance-invite-targets" class="vote-grid"></div>
                </div>
            </div>

            <div id="dead-controls" class="form-section hidden">
                <h3>üëª Hayalet Modu</h3>
                <div style="display: flex; gap: 10px; justify-content: center;">
                    <button class="btn btn-secondary" onclick="haunt('vibrate')">üì≥ Titret</button>
                    <button class="btn btn-secondary" onclick="haunt('jumpscare')">üëÅÔ∏è Korkut</button>
                </div>
            </div>

            <!-- Oyun Sohbet -->
            <div class="chat-container">
                <div id="game-chat" class="chat-messages"></div>
                <div class="chat-input-area">
                    <input type="text" id="game-chat-input" placeholder="Mesaj yaz..."
                        onkeypress="if(event.key==='Enter') sendGameChat()">
                    <button class="btn btn-primary" onclick="sendGameChat()">‚û§</button>
                </div>
            </div>

            <!-- Voice Chat Controls -->
            <div id="voice-chat-controls" class="hidden"
                style="position: absolute; bottom: 100px; right: 20px; z-index: 100;">
                <button id="btn-mic"
                    style="width: 60px; height: 60px; border-radius: 50%; border: none; background: #444; color: white; font-size: 1.5rem; box-shadow: 0 4px 10px rgba(0,0,0,0.3); cursor: pointer; transition: all 0.2s;"
                    onmousedown="startTalking()" onmouseup="stopTalking()" ontouchstart="startTalking()"
                    ontouchend="stopTalking()">
                    üéôÔ∏è
                </button>
                <div id="voice-status" style="font-size: 0.8rem; text-align: center; margin-top: 5px; opacity: 0.7;">
                    Bas-Konu≈ü</div>
            </div>

            <!-- Version Footer -->
            <!-- Version Footer -->
            <div style="text-align: center; margin-top: 10px; opacity: 0.5; font-size: 0.8rem;"></div>
        </div>

        <!-- OYUN SONU EKRANI -->
        <div id="screen-end" class="screen">
            <h1 id="end-title" style="font-size: 2rem; text-align: center; margin-bottom: 20px;"></h1>
            <p id="end-message" style="text-align: center; margin-bottom: 30px;"></p>

            <div id="end-host-controls" class="hidden" style="margin-bottom: 20px;">
                <button class="btn btn-primary" onclick="resetGame()">üîÑ YENƒ∞ OYUN</button>
            </div>

            <button class="btn btn-primary" onclick="backToHome()">Ana Men√ºye D√∂n</button>
        </div>

        <!-- DUEL OVERLAY -->
        <div id="duel-overlay" class="hidden">
            <h2 style="color: white; margin-bottom: 20px;">D√úELLO!</h2>
            <button id="duel-btn" onclick="duelClick()">TIKLA!</button>
        </div>
    </div>

    <div class="toast-container" id="toast-container"></div>

    <script>
        // ========== GLOBAL STATE ==========
        let peer = null;
        let connections = {};
        let isHost = false;
        let myPeerId = null;
        let myUsername = '';
        let roomCode = '';
        let hostConnection = null;

        // Lobby System
        let lobbyConnection = null;
        let isLobbyManager = false;
        // G√ºnl√ºk ID deƒüi≈üimi basit √ß√∂z√ºm (Herkes aynƒ± g√ºn aynƒ± lobiye d√º≈üecek)
        const LOBBY_ID = 'vampir-koylu-master-lobby-' + new Date().getDate();

        let gameState = {
            phase: 'lobby',
            players: {},
            vampireCount: 1,
            duration: 60,
            voteDuration: 30,
            roomName: '',
            password: '',
            nightActions: {},
            countdown: 60,
            chaosEvent: null,
            duelScores: {},
            hunterTarget: null,
            witchPotions: { heal: true, poison: true },
            // ƒ∞ttifak sistemi
            allianceEnabled: false,
            alliances: {}, // { allianceId: [playerId1, playerId2, ...] }
            allianceInvites: {}, // { targetPlayerId: { from: playerId, allianceId: id } }
            nextAllianceId: 1,
            // Dinamik rol ayarlarƒ±
            roles: {
                doctor: true,
                seer: true,
                traitor: false,
                hunter: false,
                witch: false,
                sheriff: false
            }
        };

        let countdownInterval = null;

        // ========== UTILITIES ==========
        function showScreen(name) {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            document.getElementById('screen-' + name).classList.add('active');

            // Voice Chat UI Visibility
            const voiceControls = document.getElementById('voice-chat-controls');
            if (name === 'game' && gameState.voiceEnabled) {
                voiceControls.classList.remove('hidden');
            } else {
                voiceControls.classList.add('hidden');
            }
        }

        function showToast(message, type = 'info') {
            const container = document.getElementById('toast-container');
            const toast = document.createElement('div');
            toast.className = 'toast ' + type;
            toast.innerText = message;
            container.appendChild(toast);
            setTimeout(() => toast.remove(), 3000);
        }

        function generateRoomCode() {
            const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
            let code = '';
            for (let i = 0; i < 4; i++) {
                code += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return code;
        }

        function copyRoomCode() {
            navigator.clipboard.writeText(roomCode);
            showToast('Oda kodu kopyalandƒ±!');
        }

        // ========== PEER CONNECTION ==========
        async function initApp() {
            await initPeer();
            connectToLobby();
        }

        function initPeer(id = null) {
            return new Promise((resolve, reject) => {
                if (peer && !peer.destroyed && !peer.disconnected) {
                    resolve(peer.id);
                    return;
                }

                const config = {
                    config: {
                        iceServers: [
                            // STUN (Discovery)
                            { urls: 'stun:stun.l.google.com:19302' },
                            { urls: 'stun:stun1.l.google.com:19302' },
                            { urls: 'stun:global.stun.twilio.com:3478' },
                            // TURN (Relay - Critical for Home NATs!)
                            {
                                urls: 'turn:openrelay.metered.ca:80',
                                username: 'openrelayproject',
                                credential: 'openrelayproject'
                            },
                            {
                                urls: 'turn:openrelay.metered.ca:443',
                                username: 'openrelayproject',
                                credential: 'openrelayproject'
                            },
                            {
                                urls: 'turn:openrelay.metered.ca:443?transport=tcp',
                                username: 'openrelayproject',
                                credential: 'openrelayproject'
                            }
                        ],
                        sdpSemantics: 'unified-plan',
                        iceCandidatePoolSize: 10
                    },
                    debug: 1
                };

                try {
                    if (peer) peer.destroy(); // Clean up old
                    peer = id ? new Peer(id, config) : new Peer(config);
                } catch (e) {
                    reject(e);
                    return;
                }

                const timeout = setTimeout(() => {
                    reject(new Error('Peer connection timed out (10s). Check network.'));
                }, 10000);

                peer.on('open', (peerId) => {
                    clearTimeout(timeout);
                    myPeerId = peerId;
                    console.log('My ID:', peerId);
                    resolve(peerId);
                });

                peer.on('connection', (conn) => {
                    handleNewConnection(conn);
                });

                peer.on('error', (err) => {
                    clearTimeout(timeout);
                    console.error('Peer error:', err);
                    if (err.type === 'unavailable-id') {
                        // Retry handled by logic or reject
                        reject(err);
                    } else {
                        // Don't necessarily reject on all errors, but for init we might want to
                        // invalid-key, ssl-unavailable, etc.
                        // reject(err);
                    }
                });
            });
        }

        // LOBBY LOGIC
        function connectToLobby() {
            if (myPeerId === LOBBY_ID) return;

            const conn = peer.connect(LOBBY_ID);

            conn.on('open', () => {
                console.log('Connected to Lobby');
                lobbyConnection = conn;
                conn.send({ type: 'get_rooms' });
                conn.on('data', (data) => {
                    if (data.type === 'room_list') updateRoomListUI(data.rooms);
                });
            });

            conn.on('error', () => {
                becomeLobbyManager();
            });

            setTimeout(() => {
                if (!lobbyConnection && !isLobbyManager) becomeLobbyManager();
            }, 3000);
        }

        async function becomeLobbyManager() {
            if (isHost) return; // CRITICAL: Don't become lobby manager if running a game!
            if (isLobbyManager) return;
            if (peer) peer.destroy();

            try {
                await initPeer(LOBBY_ID);
                isLobbyManager = true;
                console.log('I am Lobby Manager');
                showToast('Lobi Y√∂neticisi Oldun!', 'info');
                updateRoomListUI(knownRooms);
            } catch (e) {
                initPeer();
                setTimeout(connectToLobby, 2000);
            }
        }

        let knownRooms = {};

        function handleLobbyMessage(conn, data) {
            if (data.type === 'register_room') {
                knownRooms[data.code] = data.info;
                broadcastRooms();
            } else if (data.type === 'get_rooms') {
                conn.send({ type: 'room_list', rooms: knownRooms });
            }
        }

        function broadcastRooms() {
            Object.values(connections).forEach(c => {
                if (c.open) c.send({ type: 'room_list', rooms: knownRooms });
            });
        }

        function updateRoomListUI(rooms) {
            const list = document.getElementById('active-rooms-list');
            list.innerHTML = '';

            const roomKeys = Object.keys(rooms);
            if (roomKeys.length === 0) {
                list.innerHTML = '<p style="opacity:0.6;font-size:0.9rem;">Aktif oda yok.</p>';
                return;
            }

            roomKeys.forEach(code => {
                const r = rooms[code];
                const div = document.createElement('div');
                div.style.background = 'rgba(255,255,255,0.1)';
                div.style.padding = '10px';
                div.style.borderRadius = '8px';
                div.style.marginBottom = '5px';
                div.style.display = 'flex';
                div.style.justifyContent = 'space-between';
                div.style.alignItems = 'center';
                div.style.cursor = 'pointer';
                div.onclick = () => {
                    document.getElementById('room-code-input').value = code;
                    showJoinRoom();
                };

                div.innerHTML = `<div><strong>${r.name}</strong> ${r.locked ? 'üîí' : ''}<br><small style="color:#aaa">${code}</small></div>`;
                list.appendChild(div);
            });
        }

        function handleNewConnection(conn) {
            // Setup connection handlers
            const setupConnection = () => {
                connections[conn.peer] = conn;
                console.log('Connection registered:', conn.peer);
                conn.on('data', (data) => {
                    console.log('Data from', conn.peer, ':', data.type);
                    if (isLobbyManager) handleLobbyMessage(conn, data);
                    else handleMessage(conn.peer, data);
                });
                conn.on('close', () => handleDisconnect(conn.peer));
            };

            // CRITICAL: Check if connection is already open!
            // PeerJS sometimes delivers connections that are already open
            if (conn.open) {
                setupConnection();
            } else {
                conn.on('open', setupConnection);
            }
        }

        function handleDisconnect(peerId) {
            delete connections[peerId];
            if (isHost && gameState.players[peerId]) {
                delete gameState.players[peerId];
                broadcastState();
            }
        }

        function broadcast(data) {
            const connKeys = Object.keys(connections);
            console.log('Broadcasting', data.type, 'to', connKeys.length, 'connections:', connKeys);
            Object.entries(connections).forEach(([peerId, conn]) => {
                console.log('  -> Sending to', peerId, 'open:', conn.open);
                if (conn.open) {
                    try {
                        conn.send(data);
                        console.log('  -> Sent successfully to', peerId);
                    } catch (e) {
                        console.error('  -> Send failed to', peerId, e);
                    }
                } else {
                    console.log('  -> Skipped (not open):', peerId);
                }
            });
        }

        function sendToHost(data) {
            if (hostConnection && hostConnection.open) {
                hostConnection.send(data);
            }
        }

        function handleMessage(fromPeerId, data) {
            switch (data.type) {
                case 'join':
                    console.log('JOIN received from:', fromPeerId, 'isHost:', isHost);
                    if (isHost) {
                        console.log('Processing join as Host...');
                        // ≈ûifre Kontrol√º
                        if (gameState.password && gameState.password !== data.password) {
                            console.log('Password mismatch, rejecting...');
                            const conn = connections[fromPeerId];
                            if (conn) {
                                conn.send({ type: 'chat', sender: 'Sƒ∞STEM', message: 'Hatalƒ± ≈ûifre! Baƒülantƒ± kesiliyor...', chatType: 'lobby' });
                                setTimeout(() => conn.close(), 1000);
                            }
                            return;
                        }

                        console.log('Adding player:', data.username);
                        gameState.players[fromPeerId] = {
                            name: data.username,
                            role: null,
                            isAlive: true,
                            vote: null
                        };
                        console.log('Current players:', Object.keys(gameState.players));
                        console.log('Calling broadcastState...');
                        broadcastState();
                    } else {
                        console.log('NOT HOST, ignoring join message');
                    }
                    break;

                // --- ALLIANCE EVENTS (Host Only) ---
                case 'alliance_invite':
                    if (isHost && gameState.allianceEnabled) {
                        const myAlliance = getMyAllianceForPlayer(fromPeerId);
                        const allianceId = myAlliance ? myAlliance.id : gameState.nextAllianceId;

                        if (!myAlliance) {
                            gameState.alliances[allianceId] = [fromPeerId];
                            gameState.nextAllianceId++;
                        }

                        gameState.allianceInvites[data.target] = { from: fromPeerId, allianceId: allianceId };
                        broadcastState();
                    }
                    break;

                case 'alliance_accept':
                    if (isHost && gameState.allianceEnabled) {
                        const invite = gameState.allianceInvites[fromPeerId];
                        if (invite) {
                            if (!gameState.alliances[invite.allianceId]) {
                                gameState.alliances[invite.allianceId] = [invite.from];
                            }
                            gameState.alliances[invite.allianceId].push(fromPeerId);
                            delete gameState.allianceInvites[fromPeerId];
                            broadcastState();
                        }
                    }
                    break;

                case 'alliance_reject':
                    if (isHost && gameState.allianceEnabled) {
                        delete gameState.allianceInvites[fromPeerId];
                        broadcastState();
                    }
                    break;

                case 'alliance_leave':
                    if (isHost && gameState.allianceEnabled) {
                        const alliance = getMyAllianceForPlayer(fromPeerId);
                        if (alliance) {
                            const idx = gameState.alliances[alliance.id].indexOf(fromPeerId);
                            if (idx > -1) gameState.alliances[alliance.id].splice(idx, 1);
                            if (gameState.alliances[alliance.id].length === 0) {
                                delete gameState.alliances[alliance.id];
                            }
                            broadcastState();
                        }
                    }
                    break;

                case 'state':
                    gameState = data.state;
                    updateUI();
                    break;

                case 'chat':
                    addChatMessage(data.sender, data.message, data.chatType, data.isGhost);
                    if (isHost) broadcast(data);
                    break;

                case 'notification':
                    showToast(data.message, data.urgency === 'high' ? 'error' : 'info');
                    if (data.urgency === 'high' && navigator.vibrate) navigator.vibrate([200, 100, 200]);
                    break;

                case 'vote':
                    if (isHost) {
                        gameState.players[fromPeerId].vote = data.target;
                        // NEW FEATURE: Changeable votes - do not auto-resolve
                        // checkAllVoted();
                        broadcastState(); // Show updated vote to everyone
                    }
                    break;

                case 'night_action':
                    if (isHost) {
                        gameState.nightActions[fromPeerId] = { action: data.action, target: data.target };
                        // NEW FEATURE: Changeable Night Actions - do not auto-resolve
                        // checkAllNightActions();

                        // SEER FIX: Immediate Feedback + NERF (1 Time Use, Masked Role)
                        if (data.action === 'inspect' && data.target) {
                            if (gameState.abilitiesUsed && gameState.abilitiesUsed[fromPeerId]) {
                                const conn = connections[fromPeerId];
                                if (conn) conn.send({ type: 'notification', message: '‚ùå Kahin g√ºc√ºn√º bu oyunda zaten kullandƒ±n!', urgency: 'high' });
                                return;
                            }

                            const targetPlayer = gameState.players[data.target];
                            if (targetPlayer) {
                                // Mark used
                                if (!gameState.abilitiesUsed) gameState.abilitiesUsed = {};
                                gameState.abilitiesUsed[fromPeerId] = true;

                                const isBad = ['vampire', 'traitor'].includes(targetPlayer.role);
                                // NERF: Do NOT show exact role. Only Friend/Enemy.
                                const msg = `üîÆ KAHƒ∞N G√ñR√úS√ú: ${targetPlayer.name} bir ${isBad ? 'üî¥ (D√ú≈ûMAN)' : 'üü¢ (DOST)'}`;

                                // Send ONLY to the Seer
                                const seerConn = connections[fromPeerId];
                                if (seerConn && seerConn.open) {
                                    seerConn.send({ type: 'notification', message: msg, urgency: 'high' });
                                }
                            }
                        }
                    }
                    break;

                case 'vampire_tie_vote':
                    if (isHost && gameState.phase === 'vampire_decision') {
                        executeVoteDeath(data.target);
                    }
                    break;

                case 'haunt':
                    if (isHost) broadcast({ type: 'haunt_effect', effect: data.effect });
                    break;

                case 'haunt_effect':
                    triggerHauntEffect(data.effect);
                    break;

                case 'duel_start':
                    showDuelOverlay();
                    break;

                case 'duel_click':
                    if (isHost) {
                        gameState.duelScores[fromPeerId] = (gameState.duelScores[fromPeerId] || 0) + 1;
                    }
                    break;

                case 'hunter_revenge':
                    if (isHost && data.target) {
                        gameState.players[data.target].isAlive = false;
                        killAllianceMembers(data.target); // ƒ∞ttifak arkada≈ülarƒ±nƒ± da √∂ld√ºr
                        const targetName = gameState.players[data.target].name;
                        const targetRole = gameState.players[data.target].role;
                        document.getElementById('game-message').innerText += ` üèπ Avcƒ± ${targetName}'i beraberinde g√∂t√ºrd√º! (${getRoleEmoji(targetRole)})`;
                        broadcastState();
                        if (!checkWin()) setTimeout(() => startNightPhase(), 3000);
                    }
                    break;

                case 'game_start':
                    if (data.state) gameState = data.state;
                    showScreen('game');
                    updateUI();
                    if (gameState.voiceEnabled) joinVoiceChat(); // Oyuncular da katƒ±lsƒ±n
                    break;

                case 'game_end':
                    if (data.type === 'game_end') showEndScreen(data.winner, data.message);
                    break;
                case 'game_reset':
                    showScreen('lobby');
                    showToast('üîÑ Host oyunu sƒ±fƒ±rladƒ±!');
                    break;
            }
        }

        function broadcast(data) {
            if (!isHost) return;
            Object.values(connections).forEach(conn => {
                if (conn && conn.open) {
                    conn.send(data);
                }
            });
            // Bots don't need network messages
        }

        function broadcastState() {
            broadcast({ type: 'state', state: gameState });
            updateUI();
        }

        // ========== ROOM & GAME LOGIC ==========
        async function createRoom() {
            try {
                console.log('Create Room clicked');
                myUsername = document.getElementById('username-input').value.trim();
                if (!myUsername) return showToast('L√ºtfen ismini gir!', 'error');

                roomCode = generateRoomCode();
                gameState.roomName = document.getElementById('room-name-input').value || 'Oda ' + roomCode;
                gameState.password = document.getElementById('room-password-input').value.trim();
                gameState.vampireCount = parseInt(document.getElementById('vampire-count-input').value);
                gameState.duration = parseInt(document.getElementById('duration-input').value);
                gameState.voteDuration = parseInt(document.getElementById('vote-duration-input').value) || 30;

                // Create Room UI immediately
                showToast('Oda olu≈üturuluyor...', 'info');

                // IMPORTANT: Set isHost BEFORE initPeer so connection handlers work correctly!
                isHost = true;
                isLobbyManager = false; // CRITICAL: Stop acting as lobby manager when hosting a game!

                // CRITICAL: Host must register with roomCode as their Peer ID!
                // This allows clients to connect via peer.connect(roomCode)
                try {
                    if (peer) peer.destroy(); // Always recreate to ensure correct ID
                    await initPeer(roomCode); // <-- Use roomCode as Peer ID!
                } catch (e) {
                    console.error('PeerJS init failed:', e);
                    isHost = false; // Reset on failure
                    showToast('Sunucu baƒülantƒ± hatasƒ±. L√ºtfen tekrar deneyin.', 'error');
                    return; // Cannot proceed without valid peer
                }

                // SETUP GAME STATE
                gameState.players[myPeerId] = { name: myUsername, role: null, isAlive: true, vote: null };

                gameState.voiceEnabled = document.getElementById('enable-voice').checked;
                gameState.roles = {
                    doctor: document.getElementById('role-doctor').checked,
                    seer: document.getElementById('role-seer').checked,
                    traitor: document.getElementById('role-traitor').checked,
                    hunter: document.getElementById('role-hunter').checked,
                    witch: document.getElementById('role-witch').checked,
                    sheriff: document.getElementById('role-sheriff').checked
                };
                gameState.witchPotions = { heal: true, poison: true };
                gameState.allianceEnabled = document.getElementById('enable-alliance').checked;
                gameState.alliances = {};
                gameState.allianceInvites = {};
                gameState.nextAllianceId = 1;

                // IMMEDIATELY SHOW LOBBY (Don't wait for audio/lobby sync)
                document.getElementById('room-code-display').innerText = roomCode;
                document.getElementById('lobby-title').innerText = gameState.roomName;
                document.getElementById('host-controls').classList.remove('hidden');

                // Add Bot Button Check
                if (!document.getElementById('btn-add-bot')) {
                    const btnBot = document.createElement('button');
                    btnBot.id = 'btn-add-bot';
                    btnBot.className = 'btn btn-secondary';
                    btnBot.innerText = 'ü§ñ Bot Ekle';
                    btnBot.style.marginTop = '10px';
                    btnBot.onclick = addBot;
                    document.getElementById('host-controls').appendChild(btnBot);
                }

                showScreen('lobby');
                updateLobbyPlayers();
                showToast('Oda kuruldu: ' + roomCode, 'success');

                // BACKGROUND TASKS (Non-blocking)
                (async () => {
                    // 1. Audio Init
                    if (gameState.voiceEnabled) {
                        try {
                            showToast('Mikrofon hazƒ±rlanƒ±yor...', 'info');
                            await initAudio();
                        } catch (e) {
                            console.error('Background Audio Init Failed', e);
                            showToast('Mikrofon a√ßƒ±lmadƒ±, ama oyun devam ediyor.', 'warning');
                        }
                    }
                    // 2. Lobby Announce
                    try {
                        announceRoom();
                        setInterval(announceRoom, 3000);
                    } catch (e) {
                        console.error('Lobby announce failed', e);
                    }
                })();

            } catch (e) {
                console.error(e);
                showToast('Oda kurma hatasƒ±: ' + e.message, 'error');
            }
        }


        // ========== BOT SYSTEM ==========
        function addBot() {
            if (!isHost) return;
            const botId = 'Bot-' + Math.floor(Math.random() * 1000);
            const botName = 'Bot ' + (Object.keys(gameState.players).length + 1);

            gameState.players[botId] = {
                name: botName,
                role: null,
                isAlive: true,
                vote: null,
                isBot: true // Flag to identify bots
            };

            updateLobbyPlayers();
            broadcastState();
            showToast(botName + ' eklendi!');
        }

        function announceRoom() {
            if (!isHost) return;
            const info = {
                host: myUsername,
                vampires: gameState.vampireCount,
                players: Object.keys(gameState.players).length
            };

            // Send to Lobby Manager (Specific Connection)
            if (lobbyConnection && lobbyConnection.open) {
                lobbyConnection.send({ type: 'register_room', code: roomCode, info: info });
            } else {
                // Try to reconnect or broadcast if we became manager
                connectToLobby();
            }
        }

        async function joinRoom() {
            myUsername = document.getElementById('username-input').value.trim();
            roomCode = document.getElementById('room-code-input').value.trim().toUpperCase();
            const password = document.getElementById('join-password-input').value.trim();

            if (!myUsername || !roomCode) return showToast('Bilgileri gir!', 'error');

            showToast('Baƒülanƒ±lƒ±yor...', 'info');

            try {
                if (document.getElementById('enable-voice')?.checked || true) initAudio(); // Katƒ±lan da izin versin (Varsayƒ±lan true)
                if (peer && !peer.destroyed) {
                    // Peer aktif, devam et
                } else {
                    await initPeer();
                }

                if (document.getElementById('enable-voice')?.checked || true) initAudio(); // Katƒ±lan da izin versin

                hostConnection = peer.connect(roomCode, { reliable: true, serialization: 'json' });

                const connectionTimeout = setTimeout(async () => {
                    showToast('ƒ∞lk deneme ba≈üarƒ±sƒ±z... Yeniden deneniyor...', 'info');

                    // Fallback Strategy: Destroy and retry with FULL config including TURN
                    if (peer) peer.destroy();

                    try {
                        // FULL Config with TURN servers for NAT relay
                        const turnConfig = {
                            config: {
                                iceServers: [
                                    { urls: 'stun:stun.l.google.com:19302' },
                                    { urls: 'stun:global.stun.twilio.com:3478' },
                                    {
                                        urls: 'turn:openrelay.metered.ca:80',
                                        username: 'openrelayproject',
                                        credential: 'openrelayproject'
                                    },
                                    {
                                        urls: 'turn:openrelay.metered.ca:443',
                                        username: 'openrelayproject',
                                        credential: 'openrelayproject'
                                    },
                                    {
                                        urls: 'turn:openrelay.metered.ca:443?transport=tcp',
                                        username: 'openrelayproject',
                                        credential: 'openrelayproject'
                                    }
                                ],
                                iceCandidatePoolSize: 10
                            },
                            debug: 2
                        };
                        peer = new Peer(turnConfig);
                        await new Promise((resolve, reject) => {
                            const t = setTimeout(() => reject(new Error('Fallback timeout')), 15000);
                            peer.on('open', () => { clearTimeout(t); resolve(); });
                            peer.on('error', (e) => { clearTimeout(t); reject(e); });
                        });

                        hostConnection = peer.connect(roomCode, { reliable: true, serialization: 'json' });

                        // Final timeout for fallback
                        const finalTimeout = setTimeout(() => {
                            showToast('Baƒülantƒ± kurulamadƒ±! Host √ßevrimi√ßi deƒüil veya oda kapatƒ±lmƒ±≈ü olabilir.', 'error');
                        }, 15000);

                        hostConnection.on('open', () => {
                            clearTimeout(finalTimeout);
                            connections[roomCode] = hostConnection;
                            hostConnection.send({ type: 'join', username: myUsername, password: password });
                            hostConnection.on('data', d => handleMessage(roomCode, d));
                            document.getElementById('room-code-display').innerText = roomCode;
                            showScreen('lobby');
                            showToast('Baƒülandƒ±! (TURN Relay)', 'success');
                        });

                        hostConnection.on('error', () => {
                            clearTimeout(finalTimeout);
                            showToast('Bu oda bulunamadƒ± veya kapatƒ±lmƒ±≈ü.', 'error');
                        });

                    } catch (fallbackErr) {
                        console.error('Fallback failed:', fallbackErr);
                        showToast('Baƒülantƒ± tamamen ba≈üarƒ±sƒ±z. Host √ßevrimi√ßi mi kontrol edin.', 'error');
                    }
                }, 10000); // 10s timeout for first attempt

                hostConnection.on('open', () => {
                    clearTimeout(connectionTimeout);
                    connections[roomCode] = hostConnection;

                    // CRITICAL: Set up data listener BEFORE sending join!
                    // Host responds immediately, we must be ready to receive
                    hostConnection.on('data', d => {
                        console.log('Received from host:', d.type);
                        handleMessage(roomCode, d);
                    });

                    // NOW send join after listener is ready
                    hostConnection.send({ type: 'join', username: myUsername, password: password });

                    document.getElementById('room-code-display').innerText = roomCode;
                    showScreen('lobby');
                    updateUI(); // Ensure lobby players are rendered
                    showToast('Baƒülandƒ±!', 'success');
                });

                hostConnection.on('error', (err) => {
                    clearTimeout(connectionTimeout);
                    console.error('Host connection error:', err);
                    showToast('Baƒülantƒ± hatasƒ±!', 'error');
                });

                hostConnection.on('close', () => {
                    showToast('Baƒülantƒ± koptu!', 'error');
                });
            } catch (err) {
                console.error(err);
                showToast('Hata: ' + err.message, 'error');
            }
        }

        function startGame() {
            if (!isHost) return;
            const players = Object.keys(gameState.players);
            if (players.length < 3) {
                showToast('En az 3 oyuncu gerekli!', 'error');
                return;
            }

            // Game Settings
            gameState.phase = 'day';
            gameState.day = 1;
            gameState.countdown = 10; // First day intro
            gameState.vampireCount = parseInt(document.getElementById('vampire-count-input').value) || 1;
            gameState.voteDuration = parseInt(document.getElementById('vote-duration-input').value) || 30;
            gameState.killFrequency = document.getElementById('kill-frequency-input').value || 'every'; // New Setting

            // Roles
            const roles = [];
            for (let i = 0; i < gameState.vampireCount; i++) roles.push('vampire');
            if (document.getElementById('role-doctor').checked) roles.push('doctor');
            if (document.getElementById('role-seer').checked) roles.push('seer');
            if (document.getElementById('role-traitor').checked) roles.push('traitor');
            if (document.getElementById('role-hunter').checked) roles.push('hunter');
            if (document.getElementById('role-witch').checked) roles.push('witch');
            if (document.getElementById('role-sheriff').checked) roles.push('sheriff');

            // Fill rest with Villagers
            while (roles.length < players.length) roles.push('villager');

            // Shuffle Roles (Fisher-Yates) - NEW FEATURE: Randomize Roles
            for (let i = roles.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [roles[i], roles[j]] = [roles[j], roles[i]];
            }

            // Assign Roles
            // NEW FEATURE: Shuffle Players Array to ensure position randomness too
            const shuffledPlayerIds = [...players];
            for (let i = shuffledPlayerIds.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffledPlayerIds[i], shuffledPlayerIds[j]] = [shuffledPlayerIds[j], shuffledPlayerIds[i]];
            }

            shuffledPlayerIds.forEach((id, index) => {
                gameState.players[id].role = roles[index];
                gameState.players[id].isAlive = true;
                gameState.players[id].vote = null;
            });

            // Alliance System
            gameState.allianceEnabled = document.getElementById('enable-alliance').checked;
            gameState.alliances = {};
            gameState.nextAllianceId = 1;
            gameState.abilitiesUsed = {}; // NEW FEATURE: Track ability usage (Seer limit)

            broadcastState();
            // Send game start signal with state to ensure sync
            broadcast({ type: 'game_start', state: gameState });

            showScreen('game'); // HOST SYNC FIX: Explicitly switch to game screen
            updateUI();

            // Send explicit role info to each player (just in case)
            Object.entries(gameState.players).forEach(([pid, p]) => {
                const conn = connections[pid];
                if (conn && conn.open) {
                    conn.send({ type: 'role_assign', role: p.role });
                }
            });

            startCountdown(() => startNightPhase());
        }

        function startDayPhase() {
            gameState.phase = 'day';
            gameState.countdown = gameState.duration;
            gameState.chaosEvent = null;

            // Chaos Event (%50 ≈üans)
            const events = [
                { id: 'blind', name: 'üôà K√ñR ADALET', desc: 'Oylar gizli olacak!' },
                { id: 'silence', name: 'ü§ê SESSƒ∞ZLƒ∞K', desc: 'Konu≈ümak yasak!' },
                { id: 'double', name: '‚ö° √áƒ∞FTE BELA', desc: 'ƒ∞ki ki≈üi asƒ±lacak!' }
            ];

            if (Math.random() > 0.5) {
                gameState.chaosEvent = events[Math.floor(Math.random() * events.length)];
            }

            broadcastState();
            startCountdown(() => startVotingPhase());
        }

        function startVotingPhase() {
            gameState.phase = 'voting';
            gameState.countdown = gameState.voteDuration || 30;
            Object.values(gameState.players).forEach(p => p.vote = null);
            broadcastState();
            broadcast({ type: 'notification', message: `‚ö†Ô∏è OYLAMA BA≈ûLADI! ${gameState.countdown} saniyeniz var!`, urgency: 'high' });

            // Show Alert
            const modal = document.createElement('div');
            modal.style.position = 'fixed'; modal.style.top = '20%'; modal.style.left = '50%'; modal.style.transform = 'translate(-50%, -50%)';
            modal.style.background = 'red'; modal.style.color = 'white'; modal.style.padding = '20px'; modal.style.zIndex = '9999';
            modal.style.fontWeight = 'bold'; modal.style.borderRadius = '10px'; modal.innerText = '‚ö†Ô∏è OYLAMA BA≈ûLADI!';
            document.body.appendChild(modal);
            setTimeout(() => modal.remove(), 2000);

            startCountdown(() => resolveVotes());

            // Botlar Rastgele Oy Versin
            simulateBotVotes();
        }

        function simulateBotVotes() {
            if (!isHost) return;
            setTimeout(() => {
                const bots = Object.keys(gameState.players).filter(id => gameState.players[id].isBot && gameState.players[id].isAlive);
                const candidates = Object.keys(gameState.players).filter(id => gameState.players[id].isAlive);

                bots.forEach(botId => {
                    const target = candidates[Math.floor(Math.random() * candidates.length)];
                    gameState.players[botId].vote = target;
                    // Visualize bot vote (optional toast or just wait for results)
                });
                checkAllVoted();
            }, 3000 + Math.random() * 5000); // 3-8sn i√ßinde oy ver
        }

        function startNightPhase() {
            gameState.phase = 'night';
            gameState.nightActions = {};
            gameState.countdown = 30;
            broadcastState();
            startCountdown(() => resolveNight());
        }

        function startCountdown(cb) {
            if (countdownInterval) clearInterval(countdownInterval);

            // Initial sync
            if (isHost) broadcastState();

            countdownInterval = setInterval(() => {
                gameState.countdown--;

                // UPDATE UI FOR EVERYONE (Client-side prediction)
                const cdEl = document.getElementById('countdown');
                if (cdEl) cdEl.innerText = gameState.countdown;

                if (isHost) {
                    // Broadcast every second for better sync in P2P
                    broadcastState();

                    // Warning near end
                    if (gameState.countdown === 10) {
                        broadcast({ type: 'notification', message: '‚è≥ Son 10 Saniye!', urgency: 'medium' });
                    }
                }

                if (gameState.countdown <= 0) {
                    clearInterval(countdownInterval);
                    if (cb) cb();
                }
            }, 1000);
        }

        function castVote(targetId) {
            const me = gameState.players[myPeerId];
            if (!me.isAlive) return;

            if (isHost) {
                me.vote = targetId;
                // NEW FEATURE: Votes are changeable, so we DO NOT checkAllVoted()
                // checkAllVoted(); 
                broadcastState(); // Broadcast the new vote instantly
            } else {
                sendToHost({ type: 'vote', target: targetId });
            }
            showToast('Oy g√ºncellendi!');

            // NEW FEATURE: Do NOT disable buttons. Allow changing vote.
            // document.querySelectorAll('.vote-card').forEach(b => b.style.pointerEvents = 'none');
        }

        function checkAllVoted() {
            const alive = Object.values(gameState.players).filter(p => p.isAlive);
            const voted = alive.filter(p => p.vote);
            if (voted.length >= alive.length) resolveVotes();
        }

        function executeVoteDeath(victimId) {
            clearInterval(countdownInterval); // Ensure timer stops
            // Logic mirrors resolveVotes end block
            const v = gameState.players[victimId];
            if (!v) return;

            v.isAlive = false;
            killAllianceMembers(victimId);

            let msg = `‚öñÔ∏è Vampirlerin Kararƒ±: ${v.name} asƒ±ldƒ±! Rol√º: ${getRoleEmoji(v.role)} ${v.role.toUpperCase()}`;
            document.getElementById('game-message').innerText = msg;

            let hunterTriggered = false;
            if (v.role === 'hunter') {
                hunterTriggered = true;
            }

            broadcastState();

            // Handle Hunter / End Game / Night
            if (hunterTriggered && victimId === myPeerId) {
                showHunterRevenge();
            } else if (!checkWin()) {
                setTimeout(() => {
                    // Reset tie-breaker state properly before night
                    gameState.phase = 'night';
                    gameState.tiedVictims = null;
                    gameState.countdown = 0;
                    startNightPhase();
                }, 4000);
            }
        }

        function resolveVotes() {
            clearInterval(countdownInterval);
            const votes = {};

            // Oylarƒ± say - ≈ûerif 2x oy g√ºc√ºne sahip
            Object.entries(gameState.players).forEach(([id, p]) => {
                if (p.isAlive && p.vote) {
                    const voteWeight = (p.role === 'sheriff') ? 2 : 1;
                    votes[p.vote] = (votes[p.vote] || 0) + voteWeight;
                }
            });

            // Logic for max votes
            let max = 0;
            let victims = [];
            Object.entries(votes).forEach(([id, c]) => {
                if (c > max) { max = c; victims = [id]; }
                else if (c === max) victims.push(id);
            });

            // NEW FEATURE: Vampire Decision Phase (Interactive Tie-Breaker)
            // If there is a tie, Vampires get to CHOOSE who hangs.
            if (victims.length > 1) {
                // EXCEPTION regarding Chaos Event 'double': If it's double trouble, keep original logic?
                // The user request didn't specify interaction with Double Trouble. 
                // Assuming "E≈üitlik durumunda vampir se√ßsin" overrides unless specific chaos.
                // But Double Trouble explicitly kills TWO people on tie. Implementation Plan didn't cover exclude.
                // Let's check Chaos Event.
                if (gameState.chaosEvent?.id === 'double' && victims.length === 2) {
                    // Proceed to double kill (logic below)
                } else {
                    // Switch to Decision Phase
                    gameState.phase = 'vampire_decision';
                    gameState.tiedVictims = victims;
                    gameState.countdown = 15; // 15 seconds to decide

                    broadcastState();
                    broadcast({ type: 'notification', message: '‚öñÔ∏è E≈üitlik! Vampirler karar veriyor...', urgency: 'medium' });

                    startCountdown(() => {
                        // Timeout: Random or None. Defaulting to No One died (Standard).
                        // Or random? "Oylama e≈üit ve vampir se√ßmedi -> Kimse √∂lmez".
                        gameState.phase = 'night';
                        gameState.tiedVictims = null;
                        document.getElementById('game-message').innerText = '‚è≥ Karar verilemedi. Kimse asƒ±lmadƒ±.';
                        broadcastState();
                        startNightPhase(); // Skip hanging
                    });
                    return; // PAUSE RESOLUTION HERE
                }
            }

            let msg = '';
            let hunterTriggered = false;
            let hunterVictimId = null;

            if (victims.length === 1) {
                const victimId = victims[0];
                const v = gameState.players[victimId];
                v.isAlive = false;
                killAllianceMembers(victimId); // ƒ∞ttifak arkada≈ülarƒ±nƒ± da √∂ld√ºr
                msg = `‚ö∞Ô∏è ${v.name} asƒ±ldƒ±! Rol√º: ${getRoleEmoji(v.role)} ${v.role.toUpperCase()}`;

                // Avcƒ± √∂ld√ºyse hedef se√ßmesi gerekiyor
                if (v.role === 'hunter') {
                    hunterTriggered = true;
                    hunterVictimId = victimId;
                }
            } else {
                msg = '‚öñÔ∏è Oylar e≈üit, kimse asƒ±lmadƒ±.';
                if (gameState.chaosEvent?.id === 'double' && victims.length === 2) {
                    victims.forEach(id => {
                        const v = gameState.players[id];
                        v.isAlive = false;
                        killAllianceMembers(id); // ƒ∞ttifak arkada≈ülarƒ±nƒ± da √∂ld√ºr
                        if (v.role === 'hunter') {
                            hunterTriggered = true;
                            hunterVictimId = id;
                        }
                    });
                    msg = `‚ö° √áƒ∞FTE BELA! ${gameState.players[victims[0]].name} ve ${gameState.players[victims[1]].name} asƒ±ldƒ±!`;
                }
            }

            document.getElementById('game-message').innerText = msg;
            broadcastState();

            // Avcƒ± √∂ld√ºyse hedef se√ßtir
            if (hunterTriggered && hunterVictimId === myPeerId) {
                showHunterRevenge();
            } else if (!checkWin()) {
                setTimeout(() => startNightPhase(), 4000);
            }
        }

        // Avcƒ± intikamƒ± - √∂l√ºrken birini se√ßer
        function showHunterRevenge() {
            const panel = document.getElementById('night-action-panel');
            panel.classList.remove('hidden');
            document.getElementById('night-action-title').innerText = 'üèπ AVCI ƒ∞NTƒ∞KAMI';
            document.getElementById('night-action-desc').innerText = '√ñlmeden √∂nce birini se√ß!';

            const targetsDiv = document.getElementById('night-targets');
            targetsDiv.innerHTML = '';

            Object.entries(gameState.players).forEach(([id, p]) => {
                if (!p.isAlive || id === myPeerId) return;
                const btn = document.createElement('div');
                btn.className = 'vote-card';
                btn.innerHTML = p.name;
                btn.style.padding = '10px';
                btn.onclick = () => {
                    // Hedefi √∂ld√ºr
                    if (isHost) {
                        gameState.players[id].isAlive = false;
                        killAllianceMembers(id); // ƒ∞ttifak arkada≈ülarƒ±nƒ± da √∂ld√ºr
                        const targetName = gameState.players[id].name;
                        const targetRole = gameState.players[id].role;
                        document.getElementById('game-message').innerText += ` üèπ Avcƒ± ${targetName}'i beraberinde g√∂t√ºrd√º! (${getRoleEmoji(targetRole)})`;
                        broadcastState();
                        panel.classList.add('hidden');
                        if (!checkWin()) setTimeout(() => startNightPhase(), 3000);
                    } else {
                        sendToHost({ type: 'hunter_revenge', target: id });
                        panel.classList.add('hidden');
                    }
                };
                targetsDiv.appendChild(btn);
            });
        }

        function resolveNight() {
            clearInterval(countdownInterval);
            // Logic: Vampire kills, Doctor protects, Witch heals/poisons, Seer inspected locally
            const kills = [];
            const protects = [];
            let witchHeal = false;
            let witchPoison = null;

            Object.values(gameState.nightActions).forEach(a => {
                if (a.action === 'kill') kills.push(a.target);
                if (a.action === 'protect') protects.push(a.target);
                if (a.action === 'witch_heal') witchHeal = true;
                if (a.action === 'witch_poison') witchPoison = a.target;
            });

            let victim = kills[0]; // Simplification: 1 kill
            let msg = 'üåô Gece sessiz ge√ßti.';
            let deaths = [];

            // Vampir saldƒ±rƒ±sƒ±
            if (victim) {
                // Doktor veya B√ºy√ºc√º kurtardƒ± mƒ±?
                if (protects.includes(victim)) {
                    msg = 'üíâ Doktor m√ºdahalesi hayat kurtardƒ±!';
                } else if (witchHeal) {
                    msg = '‚ú® B√ºy√ºc√º iksiri hayat kurtardƒ±!';
                } else {
                    const p = gameState.players[victim];
                    p.isAlive = false;
                    killAllianceMembers(victim); // ƒ∞ttifak arkada≈ülarƒ±nƒ± da √∂ld√ºr
                    deaths.push(p.name);
                }
            }

            // B√ºy√ºc√º zehiri
            if (witchPoison && gameState.players[witchPoison]) {
                const poisoned = gameState.players[witchPoison];
                poisoned.isAlive = false;
                killAllianceMembers(witchPoison); // ƒ∞ttifak arkada≈ülarƒ±nƒ± da √∂ld√ºr
                deaths.push(poisoned.name + ' (zehirlendi)');
            }

            // Mesajƒ± olu≈ütur
            if (deaths.length > 0) {
                msg = `üíÄ ${deaths.join(' ve ')} √∂l√º bulundu!`;
            }

            document.getElementById('game-message').innerText = msg;
            broadcastState();

            // Avcƒ± gece √∂ld√ºr√ºld√ºyse intikam alabilir
            let hunterDied = false;
            let hunterVictimId = null;

            // Vampir kurbanƒ± Avcƒ± mƒ± kontrol et
            if (victim && gameState.players[victim] && !gameState.players[victim].isAlive && gameState.players[victim].role === 'hunter') {
                hunterDied = true;
                hunterVictimId = victim;
            }
            // Zehirlenen Avcƒ± mƒ± kontrol et
            if (witchPoison && gameState.players[witchPoison] && gameState.players[witchPoison].role === 'hunter') {
                hunterDied = true;
                hunterVictimId = witchPoison;
            }

            if (hunterDied && hunterVictimId === myPeerId) {
                showHunterRevenge();
            } else if (!checkWin()) {
                setTimeout(() => startDayPhase(), 4000);
            }
        }

        function checkWin() {
            const alive = Object.values(gameState.players).filter(p => p.isAlive);
            const vamps = alive.filter(p => p.role === 'vampire');
            const norms = alive.filter(p => p.role !== 'vampire'); // Traitor counts as norm for survival but helps vamps?

            // Usually win if Vamps >= Norms
            if (vamps.length === 0) {
                endGame('villagers', 'K√∂yl√ºler kazandƒ±! Vampirler temizlendi.');
                return true;
            }
            if (vamps.length >= norms.length) {
                endGame('vampires', 'Vampirler k√∂y√º ele ge√ßirdi!');
                return true;
            }
            return false;
        }

        function endGame(winner, msg) {
            broadcast({ type: 'game_end', winner, message: msg });
            showEndScreen(winner, msg);
        }

        function resetGame() {
            if (!isHost) return;

            // Reset Game State
            gameState.phase = 'lobby';
            gameState.day = 1;
            gameState.chaosEvent = null;
            gameState.nightActions = {};
            gameState.votes = {};

            // Reset Players
            Object.values(gameState.players).forEach(p => {
                p.isAlive = true;
                p.role = null;
                p.vote = null;
            });

            // Cleanup
            broadcast({ type: 'game_reset' });
            showScreen('lobby');
            updateLobbyPlayers();
        }

        // ========== CLIENT UI ==========
        function updateUI() {
            if (gameState.phase === 'lobby') {
                updateLobbyPlayers();
                return;
            }

            // Voice Chat UI Visibility Check (Continuous)
            const voiceControls = document.getElementById('voice-chat-controls');
            if (voiceControls) {
                if (gameState.voiceEnabled) {
                    voiceControls.classList.remove('hidden');
                } else {
                    voiceControls.classList.add('hidden');
                }
            }

            // Game UI
            const me = gameState.players[myPeerId];
            if (!me) return;

            // Header
            // Header
            document.getElementById('role-badge').innerText = getRoleEmoji(me.role) + ' ' + getRoleName(me.role);
            document.getElementById('role-badge').className = `role-badge role-${me.role}`;
            document.getElementById('phase-display').innerText = gameState.phase === 'day' ? '‚òÄÔ∏è G√úND√úZ' : (gameState.phase === 'night' ? 'üåô GECE' : 'üó≥Ô∏è OYLAMA');
            document.getElementById('countdown').innerText = gameState.countdown;

            // Chaos Banner
            const banner = document.getElementById('chaos-banner');
            if (gameState.chaosEvent) {
                banner.innerText = `${gameState.chaosEvent.name}: ${gameState.chaosEvent.desc}`;
                banner.style.display = 'block';
            } else {
                banner.style.display = 'none';
            }

            // Grid
            // Grid
            const grid = document.getElementById('players-grid');
            grid.innerHTML = '';

            const showingVotes = (gameState.phase === 'voting');

            Object.entries(gameState.players).forEach(([id, p]) => {
                const div = document.createElement('div');
                div.className = `vote-card ${p.isAlive ? '' : 'is-dead'}`;

                // Visual Votes: Show who they voted for (Visible to everyone as per request)
                let voteBadge = '';
                if (showingVotes) {
                    const targetId = p.vote;
                    if (targetId && gameState.players[targetId]) {
                        voteBadge = `<div style="font-size:0.75rem; color:#ffd700; margin-top:5px;">üó≥Ô∏è -> ${gameState.players[targetId].name}</div>`;
                    }
                }

                // Death Reveal: Show Role if dead
                const roleDisplay = (!p.isAlive) ? `<div style="font-size:0.8rem; color:#ff4444;">üíÄ ${getRoleEmoji(p.role)} ${getRoleName(p.role)}</div>` : '';

                div.innerHTML = `
                    <div class="player-avatar">${p.name[0]}</div>
                    <div class="player-name">${p.name}</div>
                    ${roleDisplay}
                    ${voteBadge}
                 `;

                if (gameState.phase === 'voting' && id !== myPeerId && me.isAlive) {
                    div.onclick = () => castVote(id);
                }
                grid.appendChild(div);
            });

            // Night Panel
            const nightPanel = document.getElementById('night-action-panel');
            const nightRoles = ['vampire', 'doctor', 'seer', 'witch'];
            const myAction = gameState.nightActions[myPeerId];

            // Vampire Decision Phase UI (Interactive Tie-Breaker)
            if (gameState.phase === 'vampire_decision') {
                const nightPanel = document.getElementById('night-action-panel');

                if (me.role === 'vampire') {
                    nightPanel.classList.remove('hidden');
                    document.getElementById('night-targets').innerHTML = '';
                    document.getElementById('night-action-title').innerText = '‚öñÔ∏è E≈ûƒ∞TLƒ∞K!';
                    document.getElementById('night-action-desc').innerText = 'Kƒ∞M ASILSIN? Se√ßim yap:';

                    if (gameState.tiedVictims) {
                        gameState.tiedVictims.forEach(vId => {
                            const p = gameState.players[vId];
                            const btn = document.createElement('div');
                            btn.className = 'vote-card';
                            btn.innerHTML = p.name;
                            btn.style.padding = '15px';
                            btn.style.border = '2px solid red';
                            btn.onclick = () => {
                                if (isHost) {
                                    executeVoteDeath(vId);
                                } else {
                                    sendToHost({ type: 'vampire_tie_vote', target: vId });
                                }
                            };
                            document.getElementById('night-targets').appendChild(btn);
                        });
                    }
                } else {
                    // Show banner to others
                    const banner = document.getElementById('chaos-banner');
                    banner.innerText = '‚öñÔ∏è E≈üitlik! Vampirler karar veriyor...';
                    banner.style.display = 'block';
                }
                return; // Stop standard UI update
            }

            if (gameState.phase === 'night' && me.isAlive && nightRoles.includes(me.role)) {
                // FIXED: Removed '!myAction' to allow changing selection
                nightPanel.classList.remove('hidden');
                document.getElementById('night-targets').innerHTML = '';

                let title = '', desc = '', action = '';
                if (me.role === 'vampire') { title = 'üßõ AV'; desc = '√ñld√ºr'; action = 'kill'; }
                if (me.role === 'doctor') { title = 'üíâ ƒ∞LKYARDIM'; desc = 'Koru'; action = 'protect'; }
                if (me.role === 'seer') { title = 'üîÆ KEHANET'; desc = 'Sorgula'; action = 'inspect'; }
                if (me.role === 'witch') {
                    title = '‚ú® B√úY√úC√ú';
                    desc = gameState.witchPotions.heal ? 'üíö Kurtarma veya üíÄ Zehir' : (gameState.witchPotions.poison ? 'üíÄ Zehir' : 'ƒ∞ksir kalmadƒ±');
                }

                document.getElementById('night-action-title').innerText = title;
                document.getElementById('night-action-desc').innerText = desc;

                // B√ºy√ºc√º i√ßin √∂zel panel
                if (me.role === 'witch') {
                    const targetsDiv = document.getElementById('night-targets');

                    // Kurtarma iksiri (sadece varsa)
                    if (gameState.witchPotions.heal) {
                        const healBtn = document.createElement('button');
                        healBtn.className = 'btn btn-secondary';
                        healBtn.style.margin = '5px';
                        healBtn.innerHTML = 'üíö Kurtarma ƒ∞ksiri (Vampir kurbanƒ±nƒ± kurtar)';
                        healBtn.onclick = () => {
                            if (isHost) {
                                gameState.nightActions[myPeerId] = { action: 'witch_heal', target: null };
                                gameState.witchPotions.heal = false;
                            } else {
                                sendToHost({ type: 'night_action', action: 'witch_heal', target: null });
                            }
                            // Do not hide panel - allow undo? Witch potions are one-time though.
                            // For Witch, actions are consumable immediately in this logic (potions set to false).
                            // Complex: If they re-click, logic needs to handle un-consuming? 
                            // Current logic consumes immediately locally. 
                            // Given request is mainly about Vampire, I'll leave Witch panel behavior but maybe hide it for now as potions are consumed.
                            // Actually, let's just show toast.
                            showToast('üíö Kurtarma iksiri hazƒ±rlandƒ±!');
                        };
                        targetsDiv.appendChild(healBtn);
                    }

                    // Zehir iksiri (hedef se√ß)
                    if (gameState.witchPotions.poison) {
                        const poisonLabel = document.createElement('p');
                        poisonLabel.innerHTML = '<br>üíÄ Zehir - Hedef Se√ß:';
                        poisonLabel.style.marginTop = '10px';
                        targetsDiv.appendChild(poisonLabel);

                        Object.entries(gameState.players).forEach(([id, p]) => {
                            if (!p.isAlive || id === myPeerId) return;
                            const btn = document.createElement('div');
                            btn.className = 'vote-card';
                            btn.innerHTML = p.name;
                            btn.style.padding = '10px';
                            btn.onclick = () => {
                                if (isHost) {
                                    gameState.nightActions[myPeerId] = { action: 'witch_poison', target: id };
                                    gameState.witchPotions.poison = false;
                                } else {
                                    sendToHost({ type: 'night_action', action: 'witch_poison', target: id });
                                }
                                showToast('üíÄ Zehir verildi!');
                            };
                            targetsDiv.appendChild(btn);
                        });
                    }

                    // Pas ge√ß butonu
                    const skipBtn = document.createElement('button');
                    skipBtn.className = 'btn btn-text';
                    skipBtn.style.marginTop = '15px';
                    skipBtn.innerHTML = 'Bu gece pas ge√ß';
                    skipBtn.onclick = () => {
                        if (isHost) {
                            gameState.nightActions[myPeerId] = { action: 'skip', target: null };
                        } else {
                            sendToHost({ type: 'night_action', action: 'skip', target: null });
                        }
                        // nightPanel.classList.add('hidden'); // Allow changing mind
                    };
                    targetsDiv.appendChild(skipBtn);

                } else {
                    // Diƒüer gece rolleri i√ßin normal hedef listesi (VAMPIR / DOKTOR / KAHIN)
                    Object.entries(gameState.players).forEach(([id, p]) => {
                        if (!p.isAlive || id === myPeerId) return;
                        // Vampire cannot kill fellow vampires (usually). But game allows it? 
                        // Let's filter out Vampires if user is Vampire? 
                        // Standard rules: Vampires know each other. 
                        // Existing logic didn't filter, so I won't change game rules, just UI.

                        // Check if this is the currently selected target
                        const isSelected = (myAction && myAction.target === id);

                        const btn = document.createElement('div');
                        btn.className = 'vote-card';
                        // Add selection styling
                        if (isSelected) {
                            btn.style.border = '3px solid #ffd700'; // Gold border
                            btn.style.backgroundColor = 'rgba(255, 215, 0, 0.2)';
                        }

                        btn.innerHTML = p.name;
                        btn.style.padding = '10px';
                        btn.onclick = () => {
                            if (isHost) {
                                gameState.nightActions[myPeerId] = { action, target: id };
                                if (action === 'inspect') {
                                    // SEER FEEDBACK (Host side local)
                                    if (gameState.abilitiesUsed && gameState.abilitiesUsed[myPeerId]) {
                                        showToast('‚ùå Kahin g√ºc√ºn√º kullandƒ±n!', 'error');
                                        return;
                                    }
                                    if (!gameState.abilitiesUsed) gameState.abilitiesUsed = {};
                                    gameState.abilitiesUsed[myPeerId] = true;

                                    const isBad = ['vampire', 'traitor'].includes(p.role);
                                    showToast(`üîÆ KAHƒ∞N G√ñR√úS√ú: ${p.name} bir ${isBad ? 'üî¥ D√ú≈ûMAN' : 'üü¢ DOST'}`, 'info');
                                }
                                // checkAllNightActions(); // REMOVED: Do not auto-close
                            } else {
                                sendToHost({ type: 'night_action', action, target: id });
                            }
                            // nightPanel.classList.add('hidden'); // REMOVED: Allow changing vote
                        };
                        document.getElementById('night-targets').appendChild(btn);
                    });
                }
            } else {
                nightPanel.classList.add('hidden');
            }

            // Dead Controls
            if (!me.isAlive) {
                document.getElementById('dead-controls').classList.remove('hidden');
            } else {
                document.getElementById('dead-controls').classList.add('hidden');
            }

            // Update Alliance UI
            updateAllianceUI();
        }

        function updateLobbyPlayers() {
            const list = document.getElementById('lobby-players');
            list.innerHTML = '';
            Object.values(gameState.players).forEach(p => {
                const div = document.createElement('div');
                div.className = 'player-card';
                div.innerText = p.name;
                list.appendChild(div);
            });
        }

        function getRoleEmoji(role) {
            const map = {
                vampire: 'üßõ',
                villager: 'üë®‚Äçüåæ',
                doctor: 'üíâ',
                seer: 'üîÆ',
                traitor: 'üêÄ',
                hunter: 'üèπ',
                witch: '‚ú®',
                sheriff: '‚≠ê'
            };
            return map[role] || 'üëÅÔ∏è'; // Default to Spectator Eye instead of ?
        }

        function backToHome() {
            if (peer) peer.destroy();
            location.reload();
        }

        function sendLobbyChat() {
            const inp = document.getElementById('lobby-chat-input');
            const msg = inp.value.trim();
            if (!msg) return;
            const data = { type: 'chat', sender: myUsername, message: msg, chatType: 'lobby' };
            if (isHost) {
                addChatMessage(myUsername, msg, 'lobby');
                broadcast(data);
            } else sendToHost(data);
            inp.value = '';
        }

        function sendGameChat() {
            const inp = document.getElementById('game-chat-input');
            const msg = inp.value.trim();
            if (!msg) return;
            const me = gameState.players[myPeerId];
            const isGhost = !me.isAlive;
            const data = { type: 'chat', sender: myUsername, message: msg, chatType: 'game', isGhost };
            if (isHost) {
                addChatMessage(myUsername, msg, 'game', isGhost);
                broadcast(data);
            } else sendToHost(data);
            inp.value = '';
        }

        function addChatMessage(sender, msg, type, isGhost) {
            const box = document.getElementById(type === 'lobby' ? 'lobby-chat' : 'game-chat');
            const div = document.createElement('div');
            div.className = 'chat-message';
            if (isGhost) div.style.opacity = 0.6;
            div.innerHTML = `${isGhost ? 'üëª ' : ''}<strong style="color:var(--primary-color)">${sender}:</strong> ${msg}`;
            box.appendChild(div);
            box.scrollTop = box.scrollHeight;
        }

        // Dead Actions
        function haunt(effect) {
            sendToHost({ type: 'haunt', effect });
        }

        function triggerHauntEffect(effect) {
            if (effect === 'vibrate') {
                if (navigator.vibrate) navigator.vibrate([200, 100, 200]);
                document.body.classList.add('shake');
                setTimeout(() => document.body.classList.remove('shake'), 500);
                showToast('üëª Biri seni titretiyor!', 'chaos');
            } else if (effect === 'jumpscare') {
                const ol = document.createElement('div');
                ol.style.position = 'fixed'; ol.style.top = 0; ol.style.left = 0; ol.style.width = '100%'; ol.style.height = '100%';
                ol.style.background = 'white'; ol.style.zIndex = 9999;
                document.body.appendChild(ol);
                setTimeout(() => ol.remove(), 100);
            }
        }

        // Host Helper to determine next phase logic needed
        function checkAllNightActions() {
            // simplified count check
            // In P2P host needs to know who is special.
            // We can check gameState.players roles.
        }

        // ========== SESLƒ∞ SOHBET (P2P MESH) ==========
        let localStream = null;
        let audioPeers = {}; // { peerId: MediaConnection }

        async function initAudio() {
            try {
                // Timeout promise
                const timeout = new Promise((_, reject) =>
                    setTimeout(() => reject(new Error('Mic permission request timed out')), 5000)
                );

                // Race between user action and timeout
                localStream = await Promise.race([
                    navigator.mediaDevices.getUserMedia({ audio: true, video: false }),
                    timeout
                ]);

                // Ba≈ülangƒ±√ßta sessize al (PTT)
                localStream.getAudioTracks()[0].enabled = false;
                showToast('Mikrofon hazƒ±r! Bas-Konu≈ü kullanabilirsiniz.', 'success');

                // Gelen aramalarƒ± dinle
                peer.on('call', call => {
                    call.answer(localStream);
                    call.on('stream', remoteStream => {
                        playAudioStream(remoteStream);
                    });
                });

            } catch (err) {
                console.error('Audio init error:', err);
                showToast('Mikrofon ba≈ülatƒ±lamadƒ± (ƒ∞zin verilmedi veya donanƒ±m yok). Oyun sessiz devam ediyor.', 'warning');
                // Proceed without MIC
            }
        }

        function joinVoiceChat() {
            if (!localStream) return;

            // Herkesi ara (Mesh)
            Object.keys(gameState.players).forEach(pid => {
                if (pid === myPeerId) return;
                if (gameState.players[pid].isBot) return; // SKIP BOTS in Voice Chat

                const call = peer.call(pid, localStream);
                call.on('stream', remoteStream => {
                    playAudioStream(remoteStream);
                });
                audioPeers[pid] = call;
            });
        }

        function playAudioStream(stream) {
            const audio = document.createElement('audio');
            audio.srcObject = stream;
            audio.autoplay = true;
            document.body.appendChild(audio);
        }

        function startTalking() {
            if (!localStream || !gameState.voiceEnabled) return;
            localStream.getAudioTracks()[0].enabled = true;
            document.getElementById('btn-mic').style.background = '#00d4ff';
            document.getElementById('btn-mic').style.transform = 'scale(1.1)';

            // Konu≈ütuƒüunu g√∂rselle≈ütir (Opsiyonel: Veri g√∂nder)
        }

        function stopTalking() {
            if (!localStream) return;
            localStream.getAudioTracks()[0].enabled = false;
            document.getElementById('btn-mic').style.background = '#444';
            document.getElementById('btn-mic').style.transform = 'scale(1.0)';
        }

        function toggleGlobalVoice() {
            if (!isHost) return;
            gameState.voiceEnabled = !gameState.voiceEnabled;
            broadcastState();

            const btn = document.getElementById('btn-toggle-voice');
            if (gameState.voiceEnabled) {
                btn.innerText = 'üéôÔ∏è Sesli Sohbet: A√áIK';
                btn.classList.add('btn-secondary');
                btn.classList.remove('btn-text');
            } else {
                btn.innerText = 'üîá Sesli Sohbet: KAPALI';
                btn.classList.add('btn-text');
                btn.classList.remove('btn-secondary');
            }
        }

        // ========== INIT APP & UI LISTENERS ==========

        // ========== INIT APP & UI LISTENERS ==========

        async function initApp() {
            console.log('App v1.6 Initializing...');

            // Otomatik Peer Ba≈ülat (Lobiye baƒülanmak i√ßin)
            if (!peer) {
                await initPeer();
            }

            // Lobiye Baƒülan
            connectToLobby();
        }

        function showCreateRoom() { document.getElementById('create-form').classList.remove('hidden'); document.getElementById('join-form').classList.add('hidden'); }
        function showJoinRoom() { document.getElementById('join-form').classList.remove('hidden'); document.getElementById('create-form').classList.add('hidden'); }
        function hideCreateRoom() { document.getElementById('create-form').classList.add('hidden'); }
        function hideJoinRoom() { document.getElementById('join-form').classList.add('hidden'); }
        function leaveLobby() { backToHome(); }

        function showEndScreen(winner, msg) {
            showScreen('end');
            if (winner === 'villagers') {
                document.getElementById('end-title').innerText = 'üéâ K√ñYL√úLER KAZANDI!';
                document.getElementById('end-title').style.color = '#4ade80';
            } else {
                document.getElementById('end-title').innerText = 'üßõ VAMPƒ∞RLER KAZANDI!';
                document.getElementById('end-title').style.color = '#ff4444';
            }
            document.getElementById('end-message').innerText = msg;

            // Show New Game button for Host
            if (isHost) {
                document.getElementById('end-host-controls').classList.remove('hidden');
            } else {
                document.getElementById('end-host-controls').classList.add('hidden');
            }
        }

        // ========== ƒ∞TTƒ∞FAK Sƒ∞STEMƒ∞ ==========
        function getMyAlliance() {
            for (const [allianceId, members] of Object.entries(gameState.alliances)) {
                if (members.includes(myPeerId)) return { id: allianceId, members };
            }
            return null;
        }

        function getMyAllianceForPlayer(playerId) {
            for (const [allianceId, members] of Object.entries(gameState.alliances)) {
                if (members.includes(playerId)) return { id: allianceId, members };
            }
            return null;
        }

        function showAllianceInvitePanel() {
            const panel = document.getElementById('alliance-invite-panel');
            const targets = document.getElementById('alliance-invite-targets');
            targets.innerHTML = '';

            Object.entries(gameState.players).forEach(([id, p]) => {
                if (!p.isAlive || id === myPeerId) return;
                // Zaten aynƒ± gruptaysa ekleme
                const myAlliance = getMyAlliance();
                if (myAlliance && myAlliance.members.includes(id)) return;

                const btn = document.createElement('div');
                btn.className = 'vote-card';
                btn.innerHTML = p.name;
                btn.style.padding = '10px';
                btn.style.cursor = 'pointer';
                btn.onclick = () => sendAllianceInvite(id);
                targets.appendChild(btn);
            });

            panel.classList.toggle('hidden');
        }

        function sendAllianceInvite(targetId) {
            const myAlliance = getMyAlliance();
            const allianceId = myAlliance ? myAlliance.id : gameState.nextAllianceId;

            if (isHost) {
                if (!myAlliance) {
                    // Yeni ittifak olu≈ütur
                    gameState.alliances[allianceId] = [myPeerId];
                    gameState.nextAllianceId++;
                }
                gameState.allianceInvites[targetId] = { from: myPeerId, allianceId: allianceId };
                broadcastState();
                showToast('üì® Davet g√∂nderildi!');
            } else {
                sendToHost({ type: 'alliance_invite', target: targetId });
            }
            document.getElementById('alliance-invite-panel').classList.add('hidden');
        }

        function acceptAllianceInvite() {
            const invite = gameState.allianceInvites[myPeerId];
            if (!invite) return;

            if (isHost) {
                // ƒ∞ttifaka katƒ±l
                if (!gameState.alliances[invite.allianceId]) {
                    gameState.alliances[invite.allianceId] = [invite.from];
                }
                gameState.alliances[invite.allianceId].push(myPeerId);
                delete gameState.allianceInvites[myPeerId];
                broadcastState();
                showToast('ü§ù ƒ∞ttifaka katƒ±ldƒ±n!');
            } else {
                sendToHost({ type: 'alliance_accept' });
            }
        }

        function rejectAllianceInvite() {
            if (isHost) {
                delete gameState.allianceInvites[myPeerId];
                broadcastState();
            } else {
                sendToHost({ type: 'alliance_reject' });
            }
            showToast('‚ùå Davet reddedildi');
        }

        function leaveAlliance() {
            const myAlliance = getMyAlliance();
            if (!myAlliance) return;

            if (isHost) {
                const idx = gameState.alliances[myAlliance.id].indexOf(myPeerId);
                if (idx > -1) gameState.alliances[myAlliance.id].splice(idx, 1);
                // Grupta kimse kalmadƒ±ysa sil
                if (gameState.alliances[myAlliance.id].length === 0) {
                    delete gameState.alliances[myAlliance.id];
                }
                broadcastState();
                showToast('üö™ Gruptan ayrƒ±ldƒ±n');
            } else {
                sendToHost({ type: 'alliance_leave' });
            }
        }

        function killAllianceMembers(victimId) {
            // Bir oyuncu √∂ld√ºƒü√ºnde, aynƒ± ittifaktaki herkesi √∂ld√ºr
            if (!gameState.allianceEnabled) return;

            for (const [allianceId, members] of Object.entries(gameState.alliances)) {
                if (members.includes(victimId)) {
                    members.forEach(memberId => {
                        if (gameState.players[memberId] && gameState.players[memberId].isAlive) {
                            gameState.players[memberId].isAlive = false;
                        }
                    });
                    break;
                }
            }
        }

        function updateAllianceUI() {
            if (!gameState.allianceEnabled) {
                document.getElementById('alliance-panel').classList.add('hidden');
                return;
            }

            const me = gameState.players[myPeerId];
            if (!me || !me.isAlive) {
                document.getElementById('alliance-panel').classList.add('hidden');
                return;
            }

            document.getElementById('alliance-panel').classList.remove('hidden');

            const myAlliance = getMyAlliance();
            const statusDiv = document.getElementById('alliance-status');

            if (myAlliance && myAlliance.members.length > 1) {
                const memberNames = myAlliance.members
                    .map(id => gameState.players[id]?.name || '?')
                    .join(', ');
                statusDiv.innerHTML = `<span style="color: #4ade80;">ü§ù Grubun: ${memberNames}</span>`;
                document.getElementById('btn-leave-alliance').classList.remove('hidden');
            } else {
                statusDiv.innerHTML = '<span style="color: rgba(255,255,255,0.5);">Hen√ºz bir grupta deƒüilsin</span>';
                document.getElementById('btn-leave-alliance').classList.add('hidden');
            }

            // Bekleyen davet var mƒ±?
            const invite = gameState.allianceInvites[myPeerId];
            const inviteDiv = document.getElementById('alliance-invite-pending');
            if (invite && gameState.players[invite.from]) {
                document.getElementById('alliance-invite-text').innerText =
                    `${gameState.players[invite.from].name} seni ittifaka davet ediyor!`;
                inviteDiv.classList.remove('hidden');
            } else {
                inviteDiv.classList.add('hidden');
            }
        }

        // Helper for Turkish Role Names
        function getRoleName(role) {
            const map = {
                'vampire': 'VAMPƒ∞R',
                'villager': 'K√ñYL√ú',
                'doctor': 'DOKTOR',
                'seer': 'KAHƒ∞N',
                'traitor': 'HAƒ∞N',
                'hunter': 'AVCI',
                'witch': 'B√úY√úC√ú',
                'sheriff': '≈ûERƒ∞F'
            };
            return map[role] || (role ? role.toUpperCase() : 'ƒ∞ZLEYƒ∞Cƒ∞');
        }

        // Start App
        initApp();
    </script>
</body>

</html>